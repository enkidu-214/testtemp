/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.14.8.0 (NJsonSchema v10.5.2.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

export class Client {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param page (optional) 
     * @param size (optional) 
     * @return Success
     */
    classesGET(page: number | undefined, size: number | undefined): Promise<ClassObjectQueryResponse> {
        let url_ = this.baseUrl + "/v1/Classes?";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (size === null)
            throw new Error("The parameter 'size' cannot be null.");
        else if (size !== undefined)
            url_ += "size=" + encodeURIComponent("" + size) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processClassesGET(_response);
        });
    }

    protected processClassesGET(response: Response): Promise<ClassObjectQueryResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ClassObjectQueryResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ClassObjectQueryResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    classesPOST(body: Class | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/Classes";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processClassesPOST(_response);
        });
    }

    protected processClassesPOST(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    classesPUT(body: Class | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/Classes";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processClassesPUT(_response);
        });
    }

    protected processClassesPUT(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @return Success
     */
    classesDELETE(guid: string | null): Promise<void> {
        let url_ = this.baseUrl + "/v1/Classes/{guid}";
        if (guid === undefined || guid === null)
            throw new Error("The parameter 'guid' must be defined.");
        url_ = url_.replace("{guid}", encodeURIComponent("" + guid));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processClassesDELETE(_response);
        });
    }

    protected processClassesDELETE(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @param page (optional) 
     * @param size (optional) 
     * @return Success
     */
    companyGET(page: number | undefined, size: number | undefined): Promise<CompanyObjectQueryResponse> {
        let url_ = this.baseUrl + "/v1/Company?";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (size === null)
            throw new Error("The parameter 'size' cannot be null.");
        else if (size !== undefined)
            url_ += "size=" + encodeURIComponent("" + size) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCompanyGET(_response);
        });
    }

    protected processCompanyGET(response: Response): Promise<CompanyObjectQueryResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CompanyObjectQueryResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CompanyObjectQueryResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    companyPOST(body: Company | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/Company";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCompanyPOST(_response);
        });
    }

    protected processCompanyPOST(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    companyPUT(body: Company | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/Company";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCompanyPUT(_response);
        });
    }

    protected processCompanyPUT(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @return Success
     */
    companyDELETE(guid: string | null): Promise<void> {
        let url_ = this.baseUrl + "/v1/Company/{guid}";
        if (guid === undefined || guid === null)
            throw new Error("The parameter 'guid' must be defined.");
        url_ = url_.replace("{guid}", encodeURIComponent("" + guid));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCompanyDELETE(_response);
        });
    }

    protected processCompanyDELETE(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @param page (optional) 
     * @param size (optional) 
     * @return Success
     */
    ctrlRecord(page: number | undefined, size: number | undefined): Promise<CtrlRecordObjectQueryResponse> {
        let url_ = this.baseUrl + "/v1/CtrlRecord?";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (size === null)
            throw new Error("The parameter 'size' cannot be null.");
        else if (size !== undefined)
            url_ += "size=" + encodeURIComponent("" + size) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCtrlRecord(_response);
        });
    }

    protected processCtrlRecord(response: Response): Promise<CtrlRecordObjectQueryResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CtrlRecordObjectQueryResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CtrlRecordObjectQueryResponse>(<any>null);
    }

    /**
     * @param page (optional) 
     * @param size (optional) 
     * @return Success
     */
    defenseAreaGET(page: number | undefined, size: number | undefined): Promise<DefenseAreaObjectQueryResponse> {
        let url_ = this.baseUrl + "/v1/DefenseArea?";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (size === null)
            throw new Error("The parameter 'size' cannot be null.");
        else if (size !== undefined)
            url_ += "size=" + encodeURIComponent("" + size) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDefenseAreaGET(_response);
        });
    }

    protected processDefenseAreaGET(response: Response): Promise<DefenseAreaObjectQueryResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DefenseAreaObjectQueryResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DefenseAreaObjectQueryResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    defenseAreaPOST(body: DefenseArea | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/DefenseArea";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDefenseAreaPOST(_response);
        });
    }

    protected processDefenseAreaPOST(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    defenseAreaPUT(body: DefenseArea | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/DefenseArea";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDefenseAreaPUT(_response);
        });
    }

    protected processDefenseAreaPUT(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @return Success
     */
    defenseAreaDELETE(guid: string | null): Promise<void> {
        let url_ = this.baseUrl + "/v1/DefenseArea/{guid}";
        if (guid === undefined || guid === null)
            throw new Error("The parameter 'guid' must be defined.");
        url_ = url_.replace("{guid}", encodeURIComponent("" + guid));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDefenseAreaDELETE(_response);
        });
    }

    protected processDefenseAreaDELETE(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @param page (optional) 
     * @param size (optional) 
     * @return Success
     */
    departmentGET(page: number | undefined, size: number | undefined): Promise<DepartmentObjectQueryResponse> {
        let url_ = this.baseUrl + "/v1/Department?";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (size === null)
            throw new Error("The parameter 'size' cannot be null.");
        else if (size !== undefined)
            url_ += "size=" + encodeURIComponent("" + size) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDepartmentGET(_response);
        });
    }

    protected processDepartmentGET(response: Response): Promise<DepartmentObjectQueryResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DepartmentObjectQueryResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DepartmentObjectQueryResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    departmentPOST(body: Department | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/Department";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDepartmentPOST(_response);
        });
    }

    protected processDepartmentPOST(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    departmentPUT(body: Department | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/Department";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDepartmentPUT(_response);
        });
    }

    protected processDepartmentPUT(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @return Success
     */
    departmentDELETE(guid: string | null): Promise<void> {
        let url_ = this.baseUrl + "/v1/Department/{guid}";
        if (guid === undefined || guid === null)
            throw new Error("The parameter 'guid' must be defined.");
        url_ = url_.replace("{guid}", encodeURIComponent("" + guid));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDepartmentDELETE(_response);
        });
    }

    protected processDepartmentDELETE(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @param objGuid (optional) 
     * @param startDT (optional) 
     * @param endDT (optional) 
     * @param page (optional) 
     * @param size (optional) 
     * @return Success
     */
    maintenanceRecord(objGuid: string | null | undefined, startDT: Date | undefined, endDT: Date | undefined, page: number | undefined, size: number | undefined): Promise<SentryObjectQueryResponse> {
        let url_ = this.baseUrl + "/v1/MaintenanceRecord?";
        if (objGuid !== undefined && objGuid !== null)
            url_ += "objGuid=" + encodeURIComponent("" + objGuid) + "&";
        if (startDT === null)
            throw new Error("The parameter 'startDT' cannot be null.");
        else if (startDT !== undefined)
            url_ += "startDT=" + encodeURIComponent(startDT ? "" + startDT.toISOString() : "") + "&";
        if (endDT === null)
            throw new Error("The parameter 'endDT' cannot be null.");
        else if (endDT !== undefined)
            url_ += "endDT=" + encodeURIComponent(endDT ? "" + endDT.toISOString() : "") + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (size === null)
            throw new Error("The parameter 'size' cannot be null.");
        else if (size !== undefined)
            url_ += "size=" + encodeURIComponent("" + size) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processMaintenanceRecord(_response);
        });
    }

    protected processMaintenanceRecord(response: Response): Promise<SentryObjectQueryResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SentryObjectQueryResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SentryObjectQueryResponse>(<any>null);
    }

    /**
     * @return Success
     */
    play(guid: string | null): Promise<string> {
        let url_ = this.baseUrl + "/v1/Media/play/{guid}";
        if (guid === undefined || guid === null)
            throw new Error("The parameter 'guid' must be defined.");
        url_ = url_.replace("{guid}", encodeURIComponent("" + guid));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPlay(_response);
        });
    }

    protected processPlay(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    record(body: VideoRecordParam | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/Media/record";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRecord(_response);
        });
    }

    protected processRecord(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @param page (optional) 
     * @param size (optional) 
     * @return Success
     */
    personGET(page: number | undefined, size: number | undefined): Promise<PersonObjectQueryResponse> {
        let url_ = this.baseUrl + "/v1/Person?";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (size === null)
            throw new Error("The parameter 'size' cannot be null.");
        else if (size !== undefined)
            url_ += "size=" + encodeURIComponent("" + size) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPersonGET(_response);
        });
    }

    protected processPersonGET(response: Response): Promise<PersonObjectQueryResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PersonObjectQueryResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PersonObjectQueryResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    personPOST(body: Person | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/Person";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPersonPOST(_response);
        });
    }

    protected processPersonPOST(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    personPUT(body: Person | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/Person";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPersonPUT(_response);
        });
    }

    protected processPersonPUT(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @return Success
     */
    personDELETE(guid: string | null): Promise<void> {
        let url_ = this.baseUrl + "/v1/Person/{guid}";
        if (guid === undefined || guid === null)
            throw new Error("The parameter 'guid' must be defined.");
        url_ = url_.replace("{guid}", encodeURIComponent("" + guid));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPersonDELETE(_response);
        });
    }

    protected processPersonDELETE(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    rscPOST(body: PersonRsc | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/Person/rsc";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRscPOST(_response);
        });
    }

    protected processRscPOST(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    rscPUT(body: PersonRsc | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/Person/rsc";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRscPUT(_response);
        });
    }

    protected processRscPUT(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @return Success
     */
    rscDELETE(guid: string | null): Promise<void> {
        let url_ = this.baseUrl + "/v1/Person/rsc/{guid}";
        if (guid === undefined || guid === null)
            throw new Error("The parameter 'guid' must be defined.");
        url_ = url_.replace("{guid}", encodeURIComponent("" + guid));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRscDELETE(_response);
        });
    }

    protected processRscDELETE(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @param page (optional) 
     * @param size (optional) 
     * @return Success
     */
    teamGET(page: number | undefined, size: number | undefined): Promise<TeamObjectQueryResponse> {
        let url_ = this.baseUrl + "/v1/Person/team?";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (size === null)
            throw new Error("The parameter 'size' cannot be null.");
        else if (size !== undefined)
            url_ += "size=" + encodeURIComponent("" + size) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processTeamGET(_response);
        });
    }

    protected processTeamGET(response: Response): Promise<TeamObjectQueryResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TeamObjectQueryResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TeamObjectQueryResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    teamPOST(body: Team | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/Person/team";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processTeamPOST(_response);
        });
    }

    protected processTeamPOST(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    teamPUT(body: Team | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/Person/team";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processTeamPUT(_response);
        });
    }

    protected processTeamPUT(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @return Success
     */
    teamDELETE(guid: string | null): Promise<void> {
        let url_ = this.baseUrl + "/v1/Person/team/{guid}";
        if (guid === undefined || guid === null)
            throw new Error("The parameter 'guid' must be defined.");
        url_ = url_.replace("{guid}", encodeURIComponent("" + guid));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processTeamDELETE(_response);
        });
    }

    protected processTeamDELETE(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    members(body: TeamRelPsons | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/Person/team/members";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processMembers(_response);
        });
    }

    protected processMembers(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    sentrys(body: PsonRelSentrys | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/Person/sentrys";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSentrys(_response);
        });
    }

    protected processSentrys(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @return Success
     */
    status(): Promise<PsonStatus[]> {
        let url_ = this.baseUrl + "/v1/Person/status";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processStatus(_response);
        });
    }

    protected processStatus(response: Response): Promise<PsonStatus[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PsonStatus.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PsonStatus[]>(<any>null);
    }

    /**
     * @param page (optional) 
     * @param size (optional) 
     * @return Success
     */
    sentryGET(page: number | undefined, size: number | undefined): Promise<SentryInfoObjectQueryResponse> {
        let url_ = this.baseUrl + "/v1/Sentry?";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (size === null)
            throw new Error("The parameter 'size' cannot be null.");
        else if (size !== undefined)
            url_ += "size=" + encodeURIComponent("" + size) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSentryGET(_response);
        });
    }

    protected processSentryGET(response: Response): Promise<SentryInfoObjectQueryResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SentryInfoObjectQueryResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SentryInfoObjectQueryResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    sentryPOST(body: SentryInfo | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/Sentry";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSentryPOST(_response);
        });
    }

    protected processSentryPOST(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    sentryPUT(body: SentryInfo | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/Sentry";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSentryPUT(_response);
        });
    }

    protected processSentryPUT(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @return Success
     */
    sentryDELETE(guid: string | null): Promise<void> {
        let url_ = this.baseUrl + "/v1/Sentry/{guid}";
        if (guid === undefined || guid === null)
            throw new Error("The parameter 'guid' must be defined.");
        url_ = url_.replace("{guid}", encodeURIComponent("" + guid));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSentryDELETE(_response);
        });
    }

    protected processSentryDELETE(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    persons(body: SentryRelPsons | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/Sentry/persons";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPersons(_response);
        });
    }

    protected processPersons(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    ctrl(body: DevCtrlOpParam | undefined): Promise<number> {
        let url_ = this.baseUrl + "/v1/Sentry/ctrl";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCtrl(_response);
        });
    }

    protected processCtrl(response: Response): Promise<number> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<number>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    sentryparamPOST(body: SentryParam | undefined): Promise<number> {
        let url_ = this.baseUrl + "/v1/Sentry/sentryparam";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSentryparamPOST(_response);
        });
    }

    protected processSentryparamPOST(response: Response): Promise<number> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<number>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    sentryparamGET(body: SentryParam | undefined): Promise<SentryParamNormalResponse> {
        let url_ = this.baseUrl + "/v1/Sentry/sentryparam";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "GET",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSentryparamGET(_response);
        });
    }

    protected processSentryparamGET(response: Response): Promise<SentryParamNormalResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SentryParamNormalResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SentryParamNormalResponse>(<any>null);
    }

    /**
     * @return Success
     */
    status2(): Promise<SentryStatus[]> {
        let url_ = this.baseUrl + "/v1/Sentry/status";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processStatus2(_response);
        });
    }

    protected processStatus2(response: Response): Promise<SentryStatus[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SentryStatus.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SentryStatus[]>(<any>null);
    }

    /**
     * @param page (optional) 
     * @param size (optional) 
     * @return Success
     */
    sentryAreaGET(page: number | undefined, size: number | undefined): Promise<SentryAreaObjectQueryResponse> {
        let url_ = this.baseUrl + "/v1/SentryArea?";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (size === null)
            throw new Error("The parameter 'size' cannot be null.");
        else if (size !== undefined)
            url_ += "size=" + encodeURIComponent("" + size) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSentryAreaGET(_response);
        });
    }

    protected processSentryAreaGET(response: Response): Promise<SentryAreaObjectQueryResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SentryAreaObjectQueryResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SentryAreaObjectQueryResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    sentryAreaPOST(body: SentryArea | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/SentryArea";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSentryAreaPOST(_response);
        });
    }

    protected processSentryAreaPOST(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    sentryAreaPUT(body: SentryArea | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/SentryArea";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSentryAreaPUT(_response);
        });
    }

    protected processSentryAreaPUT(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @return Success
     */
    sentryAreaDELETE(guid: string | null): Promise<void> {
        let url_ = this.baseUrl + "/v1/SentryArea/{guid}";
        if (guid === undefined || guid === null)
            throw new Error("The parameter 'guid' must be defined.");
        url_ = url_.replace("{guid}", encodeURIComponent("" + guid));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSentryAreaDELETE(_response);
        });
    }

    protected processSentryAreaDELETE(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @return Success
     */
    assess(guid: string | null): Promise<AssessResult> {
        let url_ = this.baseUrl + "/v1/SentryArea/assess/{guid}";
        if (guid === undefined || guid === null)
            throw new Error("The parameter 'guid' must be defined.");
        url_ = url_.replace("{guid}", encodeURIComponent("" + guid));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "PUT",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAssess(_response);
        });
    }

    protected processAssess(response: Response): Promise<AssessResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AssessResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AssessResult>(<any>null);
    }

    /**
     * @param page (optional) 
     * @param size (optional) 
     * @return Success
     */
    sentryRecordGET(page: number | undefined, size: number | undefined): Promise<SentryRecordObjectQueryResponse> {
        let url_ = this.baseUrl + "/v1/SentryRecord?";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (size === null)
            throw new Error("The parameter 'size' cannot be null.");
        else if (size !== undefined)
            url_ += "size=" + encodeURIComponent("" + size) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSentryRecordGET(_response);
        });
    }

    protected processSentryRecordGET(response: Response): Promise<SentryRecordObjectQueryResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SentryRecordObjectQueryResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SentryRecordObjectQueryResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    sentryRecordPOST(body: ByteDataInfo | undefined): Promise<SentryRecord> {
        let url_ = this.baseUrl + "/v1/SentryRecord";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSentryRecordPOST(_response);
        });
    }

    protected processSentryRecordPOST(response: Response): Promise<SentryRecord> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SentryRecord.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SentryRecord>(<any>null);
    }

    /**
     * @param page (optional) 
     * @param size (optional) 
     * @return Success
     */
    detail(page: number | undefined, size: number | undefined): Promise<SentryRecordDetailObjectQueryResponse> {
        let url_ = this.baseUrl + "/v1/SentryRecord/detail?";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (size === null)
            throw new Error("The parameter 'size' cannot be null.");
        else if (size !== undefined)
            url_ += "size=" + encodeURIComponent("" + size) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDetail(_response);
        });
    }

    protected processDetail(response: Response): Promise<SentryRecordDetailObjectQueryResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SentryRecordDetailObjectQueryResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SentryRecordDetailObjectQueryResponse>(<any>null);
    }

    /**
     * @return Success
     */
    detail2(id: number): Promise<SentryRecordDetail> {
        let url_ = this.baseUrl + "/v1/SentryRecord/detail/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDetail2(_response);
        });
    }

    protected processDetail2(response: Response): Promise<SentryRecordDetail> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SentryRecordDetail.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SentryRecordDetail>(<any>null);
    }

    /**
     * @param page (optional) 
     * @param size (optional) 
     * @return Success
     */
    sentryTaskGET(page: number | undefined, size: number | undefined): Promise<SentryTaskObjectQueryResponse> {
        let url_ = this.baseUrl + "/v1/SentryTask?";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (size === null)
            throw new Error("The parameter 'size' cannot be null.");
        else if (size !== undefined)
            url_ += "size=" + encodeURIComponent("" + size) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSentryTaskGET(_response);
        });
    }

    protected processSentryTaskGET(response: Response): Promise<SentryTaskObjectQueryResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SentryTaskObjectQueryResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SentryTaskObjectQueryResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    sentryTaskPOST(body: SentryTask | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/SentryTask";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSentryTaskPOST(_response);
        });
    }

    protected processSentryTaskPOST(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    sentryTaskPUT(body: SentryTask | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/SentryTask";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSentryTaskPUT(_response);
        });
    }

    protected processSentryTaskPUT(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @param page (optional) 
     * @param size (optional) 
     * @return Success
     */
    issuable(page: number | undefined, size: number | undefined): Promise<SentryTaskStatusObjectQueryResponse> {
        let url_ = this.baseUrl + "/v1/SentryTask/issuable?";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (size === null)
            throw new Error("The parameter 'size' cannot be null.");
        else if (size !== undefined)
            url_ += "size=" + encodeURIComponent("" + size) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processIssuable(_response);
        });
    }

    protected processIssuable(response: Response): Promise<SentryTaskStatusObjectQueryResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SentryTaskStatusObjectQueryResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SentryTaskStatusObjectQueryResponse>(<any>null);
    }

    /**
     * @param page (optional) 
     * @param size (optional) 
     * @return Success
     */
    issuestatus(page: number | undefined, size: number | undefined): Promise<SentryTaskStatusObjectQueryResponse> {
        let url_ = this.baseUrl + "/v1/SentryTask/issuestatus?";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (size === null)
            throw new Error("The parameter 'size' cannot be null.");
        else if (size !== undefined)
            url_ += "size=" + encodeURIComponent("" + size) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processIssuestatus(_response);
        });
    }

    protected processIssuestatus(response: Response): Promise<SentryTaskStatusObjectQueryResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SentryTaskStatusObjectQueryResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SentryTaskStatusObjectQueryResponse>(<any>null);
    }

    /**
     * @return Success
     */
    taskweather(guid: string | null): Promise<WeatherInfo> {
        let url_ = this.baseUrl + "/v1/SentryTask/taskweather/{guid}";
        if (guid === undefined || guid === null)
            throw new Error("The parameter 'guid' must be defined.");
        url_ = url_.replace("{guid}", encodeURIComponent("" + guid));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processTaskweather(_response);
        });
    }

    protected processTaskweather(response: Response): Promise<WeatherInfo> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WeatherInfo.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<WeatherInfo>(<any>null);
    }

    /**
     * @return Success
     */
    sentryTaskDELETE(guid: string | null): Promise<void> {
        let url_ = this.baseUrl + "/v1/SentryTask/{guid}";
        if (guid === undefined || guid === null)
            throw new Error("The parameter 'guid' must be defined.");
        url_ = url_.replace("{guid}", encodeURIComponent("" + guid));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSentryTaskDELETE(_response);
        });
    }

    protected processSentryTaskDELETE(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @return Success
     */
    assess2(guid: string | null): Promise<AssessResult> {
        let url_ = this.baseUrl + "/v1/SentryTask/assess/{guid}";
        if (guid === undefined || guid === null)
            throw new Error("The parameter 'guid' must be defined.");
        url_ = url_.replace("{guid}", encodeURIComponent("" + guid));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "PUT",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAssess2(_response);
        });
    }

    protected processAssess2(response: Response): Promise<AssessResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AssessResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AssessResult>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    issue(body: TaskIssueParam | undefined): Promise<number> {
        let url_ = this.baseUrl + "/v1/SentryTask/issue";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processIssue(_response);
        });
    }

    protected processIssue(response: Response): Promise<number> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<number>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    approve(body: TaskApproveParam | undefined): Promise<number> {
        let url_ = this.baseUrl + "/v1/SentryTask/approve";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processApprove(_response);
        });
    }

    protected processApprove(response: Response): Promise<number> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<number>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    innerapprove(body: TaskInnerApproveRst | undefined): Promise<number> {
        let url_ = this.baseUrl + "/v1/SentryTask/innerapprove";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processInnerapprove(_response);
        });
    }

    protected processInnerapprove(response: Response): Promise<number> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<number>(<any>null);
    }

    /**
     * @param minutes (optional) 
     * @return Success
     */
    performance(minutes: number | undefined): Promise<PerformanceRecordObjectQueryResponse> {
        let url_ = this.baseUrl + "/v1/Statistic/performance?";
        if (minutes === null)
            throw new Error("The parameter 'minutes' cannot be null.");
        else if (minutes !== undefined)
            url_ += "minutes=" + encodeURIComponent("" + minutes) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPerformance(_response);
        });
    }

    protected processPerformance(response: Response): Promise<PerformanceRecordObjectQueryResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PerformanceRecordObjectQueryResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PerformanceRecordObjectQueryResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    taskcnt(body: StatisticRequest | undefined): Promise<CountStatisticResult[]> {
        let url_ = this.baseUrl + "/v1/Statistic/sentry/taskcnt";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "GET",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processTaskcnt(_response);
        });
    }

    protected processTaskcnt(response: Response): Promise<CountStatisticResult[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CountStatisticResult.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CountStatisticResult[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    exception(body: StatisticRequest | undefined): Promise<CountStatisticResult[]> {
        let url_ = this.baseUrl + "/v1/Statistic/sentry/exception";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "GET",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processException(_response);
        });
    }

    protected processException(response: Response): Promise<CountStatisticResult[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CountStatisticResult.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CountStatisticResult[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    mileage(body: StatisticRequest | undefined): Promise<DutyDurationStatistic[]> {
        let url_ = this.baseUrl + "/v1/Statistic/sentry/mileage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "GET",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processMileage(_response);
        });
    }

    protected processMileage(response: Response): Promise<DutyDurationStatistic[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DutyDurationStatistic.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DutyDurationStatistic[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    duration(body: StatisticRequest | undefined): Promise<SentryEventStatistic[]> {
        let url_ = this.baseUrl + "/v1/Statistic/sentry/duration";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "GET",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDuration(_response);
        });
    }

    protected processDuration(response: Response): Promise<SentryEventStatistic[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SentryEventStatistic.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SentryEventStatistic[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    object(body: ObjectStatisticRequest | undefined): Promise<SingleSentryStatisticResponse> {
        let url_ = this.baseUrl + "/v1/Statistic/sentry/object";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "GET",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processObject(_response);
        });
    }

    protected processObject(response: Response): Promise<SingleSentryStatisticResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SingleSentryStatisticResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SingleSentryStatisticResponse>(<any>null);
    }

    /**
     * @param account (optional) 
     * @param password (optional) 
     * @return Success
     */
    login(account: string | null | undefined, password: string | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/System/Login?";
        if (account !== undefined && account !== null)
            url_ += "account=" + encodeURIComponent("" + account) + "&";
        if (password !== undefined && password !== null)
            url_ += "password=" + encodeURIComponent("" + password) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processLogin(_response);
        });
    }

    protected processLogin(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @return Success
     */
    logout(): Promise<void> {
        let url_ = this.baseUrl + "/v1/System/Logout";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processLogout(_response);
        });
    }

    protected processLogout(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    register(body: Person | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/System/Register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRegister(_response);
        });
    }

    protected processRegister(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @return Success
     */
    system(telephone: string | null): Promise<string> {
        let url_ = this.baseUrl + "/v1/System/telvericode{telephone}";
        if (telephone === undefined || telephone === null)
            throw new Error("The parameter 'telephone' must be defined.");
        url_ = url_.replace("{telephone}", encodeURIComponent("" + telephone));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSystem(_response);
        });
    }

    protected processSystem(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(<any>null);
    }

    /**
     * @return Success
     */
    version(): Promise<string> {
        let url_ = this.baseUrl + "/v1/System/version";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processVersion(_response);
        });
    }

    protected processVersion(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(<any>null);
    }

    /**
     * @return Success
     */
    dbversion(): Promise<DBVersion> {
        let url_ = this.baseUrl + "/v1/System/dbversion";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDbversion(_response);
        });
    }

    protected processDbversion(response: Response): Promise<DBVersion> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DBVersion.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DBVersion>(<any>null);
    }

    /**
     * @return Success
     */
    configsAll(group: string | null): Promise<SysCfg[]> {
        let url_ = this.baseUrl + "/v1/System/configs/{group}";
        if (group === undefined || group === null)
            throw new Error("The parameter 'group' must be defined.");
        url_ = url_.replace("{group}", encodeURIComponent("" + group));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processConfigsAll(_response);
        });
    }

    protected processConfigsAll(response: Response): Promise<SysCfg[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SysCfg.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SysCfg[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    configsAll2(body: string[] | null | undefined): Promise<SysCfg[]> {
        let url_ = this.baseUrl + "/v1/System/configs";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "GET",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processConfigsAll2(_response);
        });
    }

    protected processConfigsAll2(response: Response): Promise<SysCfg[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SysCfg.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SysCfg[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    configs(body: SysCfg[] | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/System/configs";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processConfigs(_response);
        });
    }

    protected processConfigs(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @param page (optional) 
     * @param size (optional) 
     * @return Success
     */
    oprecord(page: number | undefined, size: number | undefined): Promise<OpRecordObjectQueryResponse> {
        let url_ = this.baseUrl + "/v1/System/oprecord?";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (size === null)
            throw new Error("The parameter 'size' cannot be null.");
        else if (size !== undefined)
            url_ += "size=" + encodeURIComponent("" + size) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processOprecord(_response);
        });
    }

    protected processOprecord(response: Response): Promise<OpRecordObjectQueryResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OpRecordObjectQueryResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<OpRecordObjectQueryResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    upload(body: UploadFileParam | undefined): Promise<string> {
        let url_ = this.baseUrl + "/v1/System/upload";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpload(_response);
        });
    }

    protected processUpload(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    download(body: DownloadFileParam | undefined): Promise<ByteDataInfo> {
        let url_ = this.baseUrl + "/v1/System/download";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "GET",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDownload(_response);
        });
    }

    protected processDownload(response: Response): Promise<ByteDataInfo> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ByteDataInfo.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ByteDataInfo>(<any>null);
    }

    /**
     * @param page (optional) 
     * @param size (optional) 
     * @return Success
     */
    userGroupGET(page: number | undefined, size: number | undefined): Promise<UserGroupObjectQueryResponse> {
        let url_ = this.baseUrl + "/v1/UserGroup?";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (size === null)
            throw new Error("The parameter 'size' cannot be null.");
        else if (size !== undefined)
            url_ += "size=" + encodeURIComponent("" + size) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUserGroupGET(_response);
        });
    }

    protected processUserGroupGET(response: Response): Promise<UserGroupObjectQueryResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserGroupObjectQueryResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserGroupObjectQueryResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    userGroupPOST(body: UserGroup | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/UserGroup";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUserGroupPOST(_response);
        });
    }

    protected processUserGroupPOST(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    userGroupPUT(body: UserGroup | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/UserGroup";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUserGroupPUT(_response);
        });
    }

    protected processUserGroupPUT(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @return Success
     */
    userGroupDELETE(id: number): Promise<void> {
        let url_ = this.baseUrl + "/v1/UserGroup/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUserGroupDELETE(_response);
        });
    }

    protected processUserGroupDELETE(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    weather(body: WeatherReqInfo | undefined): Promise<WeatherInfo[]> {
        let url_ = this.baseUrl + "/v1/Weather";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "GET",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processWeather(_response);
        });
    }

    protected processWeather(response: Response): Promise<WeatherInfo[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(WeatherInfo.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<WeatherInfo[]>(<any>null);
    }
}

export class Paging implements IPaging {
    page?: number;
    size?: number;
    total?: number;

    constructor(data?: IPaging) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.page = _data["page"];
            this.size = _data["size"];
            this.total = _data["total"];
        }
    }

    static fromJS(data: any): Paging {
        data = typeof data === 'object' ? data : {};
        let result = new Paging();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["page"] = this.page;
        data["size"] = this.size;
        data["total"] = this.total;
        return data; 
    }
}

export interface IPaging {
    page?: number;
    size?: number;
    total?: number;
}

export class Class implements IClass {
    guid?: string | undefined;
    name?: string | undefined;
    editTime?: number;
    reserved?: string | undefined;

    constructor(data?: IClass) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.guid = _data["guid"];
            this.name = _data["name"];
            this.editTime = _data["editTime"];
            this.reserved = _data["reserved"];
        }
    }

    static fromJS(data: any): Class {
        data = typeof data === 'object' ? data : {};
        let result = new Class();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["guid"] = this.guid;
        data["name"] = this.name;
        data["editTime"] = this.editTime;
        data["reserved"] = this.reserved;
        return data; 
    }
}

export interface IClass {
    guid?: string | undefined;
    name?: string | undefined;
    editTime?: number;
    reserved?: string | undefined;
}

export class ClassObjectQueryResponse implements IClassObjectQueryResponse {
    pageInfo?: Paging;
    objects?: Class[] | undefined;

    constructor(data?: IClassObjectQueryResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pageInfo = _data["pageInfo"] ? Paging.fromJS(_data["pageInfo"]) : <any>undefined;
            if (Array.isArray(_data["objects"])) {
                this.objects = [] as any;
                for (let item of _data["objects"])
                    this.objects!.push(Class.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ClassObjectQueryResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ClassObjectQueryResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pageInfo"] = this.pageInfo ? this.pageInfo.toJSON() : <any>undefined;
        if (Array.isArray(this.objects)) {
            data["objects"] = [];
            for (let item of this.objects)
                data["objects"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IClassObjectQueryResponse {
    pageInfo?: Paging;
    objects?: Class[] | undefined;
}

export class Company implements ICompany {
    guid?: string | undefined;
    name?: string | undefined;
    address?: string | undefined;
    phone?: string | undefined;
    editTime?: number;
    reserved?: string | undefined;

    constructor(data?: ICompany) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.guid = _data["guid"];
            this.name = _data["name"];
            this.address = _data["address"];
            this.phone = _data["phone"];
            this.editTime = _data["editTime"];
            this.reserved = _data["reserved"];
        }
    }

    static fromJS(data: any): Company {
        data = typeof data === 'object' ? data : {};
        let result = new Company();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["guid"] = this.guid;
        data["name"] = this.name;
        data["address"] = this.address;
        data["phone"] = this.phone;
        data["editTime"] = this.editTime;
        data["reserved"] = this.reserved;
        return data; 
    }
}

export interface ICompany {
    guid?: string | undefined;
    name?: string | undefined;
    address?: string | undefined;
    phone?: string | undefined;
    editTime?: number;
    reserved?: string | undefined;
}

export class CompanyObjectQueryResponse implements ICompanyObjectQueryResponse {
    pageInfo?: Paging;
    objects?: Company[] | undefined;

    constructor(data?: ICompanyObjectQueryResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pageInfo = _data["pageInfo"] ? Paging.fromJS(_data["pageInfo"]) : <any>undefined;
            if (Array.isArray(_data["objects"])) {
                this.objects = [] as any;
                for (let item of _data["objects"])
                    this.objects!.push(Company.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CompanyObjectQueryResponse {
        data = typeof data === 'object' ? data : {};
        let result = new CompanyObjectQueryResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pageInfo"] = this.pageInfo ? this.pageInfo.toJSON() : <any>undefined;
        if (Array.isArray(this.objects)) {
            data["objects"] = [];
            for (let item of this.objects)
                data["objects"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ICompanyObjectQueryResponse {
    pageInfo?: Paging;
    objects?: Company[] | undefined;
}

export enum LinkWayType {
    _0 = 0,
    _1 = 1,
}

export enum PowerType {
    _0 = 0,
    _1 = 1,
    _2 = 2,
}

export enum LevelType {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
}

export enum AppearanceType {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
    _6 = 6,
}

export enum ReservedType {
    _0 = 0,
}

export class SentryInfo implements ISentryInfo {
    guid?: string | undefined;
    name?: string | undefined;
    model?: string | undefined;
    serialNum?: string | undefined;
    regNo?: string | undefined;
    pvin?: string | undefined;
    pattern?: string | undefined;
    fcName?: string | undefined;
    linkWay?: LinkWayType;
    powerType?: PowerType;
    level?: LevelType;
    appearance?: AppearanceType;
    enduranceTime?: number;
    reservedType?: ReservedType;
    editTime?: number;
    deleteTime?: number;
    picture?: string | undefined;
    reserved?: string | undefined;

    constructor(data?: ISentryInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.guid = _data["guid"];
            this.name = _data["name"];
            this.model = _data["model"];
            this.serialNum = _data["serialNum"];
            this.regNo = _data["regNo"];
            this.pvin = _data["pvin"];
            this.pattern = _data["pattern"];
            this.fcName = _data["fcName"];
            this.linkWay = _data["linkWay"];
            this.powerType = _data["powerType"];
            this.level = _data["level"];
            this.appearance = _data["appearance"];
            this.enduranceTime = _data["enduranceTime"];
            this.reservedType = _data["reservedType"];
            this.editTime = _data["editTime"];
            this.deleteTime = _data["deleteTime"];
            this.picture = _data["picture"];
            this.reserved = _data["reserved"];
        }
    }

    static fromJS(data: any): SentryInfo {
        data = typeof data === 'object' ? data : {};
        let result = new SentryInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["guid"] = this.guid;
        data["name"] = this.name;
        data["model"] = this.model;
        data["serialNum"] = this.serialNum;
        data["regNo"] = this.regNo;
        data["pvin"] = this.pvin;
        data["pattern"] = this.pattern;
        data["fcName"] = this.fcName;
        data["linkWay"] = this.linkWay;
        data["powerType"] = this.powerType;
        data["level"] = this.level;
        data["appearance"] = this.appearance;
        data["enduranceTime"] = this.enduranceTime;
        data["reservedType"] = this.reservedType;
        data["editTime"] = this.editTime;
        data["deleteTime"] = this.deleteTime;
        data["picture"] = this.picture;
        data["reserved"] = this.reserved;
        return data; 
    }
}

export interface ISentryInfo {
    guid?: string | undefined;
    name?: string | undefined;
    model?: string | undefined;
    serialNum?: string | undefined;
    regNo?: string | undefined;
    pvin?: string | undefined;
    pattern?: string | undefined;
    fcName?: string | undefined;
    linkWay?: LinkWayType;
    powerType?: PowerType;
    level?: LevelType;
    appearance?: AppearanceType;
    enduranceTime?: number;
    reservedType?: ReservedType;
    editTime?: number;
    deleteTime?: number;
    picture?: string | undefined;
    reserved?: string | undefined;
}

export class CtrlRecord implements ICtrlRecord {
    id?: number;
    sentryGuid?: string | undefined;
    command?: number;
    result?: number;
    psonGuid?: string | undefined;
    opTime?: number;
    reserved?: string | undefined;
    sentryInfo?: SentryInfo;

    constructor(data?: ICtrlRecord) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.sentryGuid = _data["sentryGuid"];
            this.command = _data["command"];
            this.result = _data["result"];
            this.psonGuid = _data["psonGuid"];
            this.opTime = _data["opTime"];
            this.reserved = _data["reserved"];
            this.sentryInfo = _data["sentryInfo"] ? SentryInfo.fromJS(_data["sentryInfo"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CtrlRecord {
        data = typeof data === 'object' ? data : {};
        let result = new CtrlRecord();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["sentryGuid"] = this.sentryGuid;
        data["command"] = this.command;
        data["result"] = this.result;
        data["psonGuid"] = this.psonGuid;
        data["opTime"] = this.opTime;
        data["reserved"] = this.reserved;
        data["sentryInfo"] = this.sentryInfo ? this.sentryInfo.toJSON() : <any>undefined;
        return data; 
    }
}

export interface ICtrlRecord {
    id?: number;
    sentryGuid?: string | undefined;
    command?: number;
    result?: number;
    psonGuid?: string | undefined;
    opTime?: number;
    reserved?: string | undefined;
    sentryInfo?: SentryInfo;
}

export class CtrlRecordObjectQueryResponse implements ICtrlRecordObjectQueryResponse {
    pageInfo?: Paging;
    objects?: CtrlRecord[] | undefined;

    constructor(data?: ICtrlRecordObjectQueryResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pageInfo = _data["pageInfo"] ? Paging.fromJS(_data["pageInfo"]) : <any>undefined;
            if (Array.isArray(_data["objects"])) {
                this.objects = [] as any;
                for (let item of _data["objects"])
                    this.objects!.push(CtrlRecord.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CtrlRecordObjectQueryResponse {
        data = typeof data === 'object' ? data : {};
        let result = new CtrlRecordObjectQueryResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pageInfo"] = this.pageInfo ? this.pageInfo.toJSON() : <any>undefined;
        if (Array.isArray(this.objects)) {
            data["objects"] = [];
            for (let item of this.objects)
                data["objects"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ICtrlRecordObjectQueryResponse {
    pageInfo?: Paging;
    objects?: CtrlRecord[] | undefined;
}

export enum AreaType {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
}

export enum AreaShape {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
}

export class DefenseArea implements IDefenseArea {
    guid?: string | undefined;
    areaNo?: string | undefined;
    name?: string | undefined;
    type?: AreaType;
    shape?: AreaShape;
    coor?: string | undefined;
    bot?: number;
    top?: number;
    times?: string | undefined;
    editTime?: number;
    deleteTime?: number;
    reserved?: string | undefined;

    constructor(data?: IDefenseArea) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.guid = _data["guid"];
            this.areaNo = _data["areaNo"];
            this.name = _data["name"];
            this.type = _data["type"];
            this.shape = _data["shape"];
            this.coor = _data["coor"];
            this.bot = _data["bot"];
            this.top = _data["top"];
            this.times = _data["times"];
            this.editTime = _data["editTime"];
            this.deleteTime = _data["deleteTime"];
            this.reserved = _data["reserved"];
        }
    }

    static fromJS(data: any): DefenseArea {
        data = typeof data === 'object' ? data : {};
        let result = new DefenseArea();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["guid"] = this.guid;
        data["areaNo"] = this.areaNo;
        data["name"] = this.name;
        data["type"] = this.type;
        data["shape"] = this.shape;
        data["coor"] = this.coor;
        data["bot"] = this.bot;
        data["top"] = this.top;
        data["times"] = this.times;
        data["editTime"] = this.editTime;
        data["deleteTime"] = this.deleteTime;
        data["reserved"] = this.reserved;
        return data; 
    }
}

export interface IDefenseArea {
    guid?: string | undefined;
    areaNo?: string | undefined;
    name?: string | undefined;
    type?: AreaType;
    shape?: AreaShape;
    coor?: string | undefined;
    bot?: number;
    top?: number;
    times?: string | undefined;
    editTime?: number;
    deleteTime?: number;
    reserved?: string | undefined;
}

export class DefenseAreaObjectQueryResponse implements IDefenseAreaObjectQueryResponse {
    pageInfo?: Paging;
    objects?: DefenseArea[] | undefined;

    constructor(data?: IDefenseAreaObjectQueryResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pageInfo = _data["pageInfo"] ? Paging.fromJS(_data["pageInfo"]) : <any>undefined;
            if (Array.isArray(_data["objects"])) {
                this.objects = [] as any;
                for (let item of _data["objects"])
                    this.objects!.push(DefenseArea.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DefenseAreaObjectQueryResponse {
        data = typeof data === 'object' ? data : {};
        let result = new DefenseAreaObjectQueryResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pageInfo"] = this.pageInfo ? this.pageInfo.toJSON() : <any>undefined;
        if (Array.isArray(this.objects)) {
            data["objects"] = [];
            for (let item of this.objects)
                data["objects"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IDefenseAreaObjectQueryResponse {
    pageInfo?: Paging;
    objects?: DefenseArea[] | undefined;
}

export class Department implements IDepartment {
    guid?: string | undefined;
    name?: string | undefined;
    editTime?: number;
    reserved?: string | undefined;

    constructor(data?: IDepartment) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.guid = _data["guid"];
            this.name = _data["name"];
            this.editTime = _data["editTime"];
            this.reserved = _data["reserved"];
        }
    }

    static fromJS(data: any): Department {
        data = typeof data === 'object' ? data : {};
        let result = new Department();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["guid"] = this.guid;
        data["name"] = this.name;
        data["editTime"] = this.editTime;
        data["reserved"] = this.reserved;
        return data; 
    }
}

export interface IDepartment {
    guid?: string | undefined;
    name?: string | undefined;
    editTime?: number;
    reserved?: string | undefined;
}

export class DepartmentObjectQueryResponse implements IDepartmentObjectQueryResponse {
    pageInfo?: Paging;
    objects?: Department[] | undefined;

    constructor(data?: IDepartmentObjectQueryResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pageInfo = _data["pageInfo"] ? Paging.fromJS(_data["pageInfo"]) : <any>undefined;
            if (Array.isArray(_data["objects"])) {
                this.objects = [] as any;
                for (let item of _data["objects"])
                    this.objects!.push(Department.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DepartmentObjectQueryResponse {
        data = typeof data === 'object' ? data : {};
        let result = new DepartmentObjectQueryResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pageInfo"] = this.pageInfo ? this.pageInfo.toJSON() : <any>undefined;
        if (Array.isArray(this.objects)) {
            data["objects"] = [];
            for (let item of this.objects)
                data["objects"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IDepartmentObjectQueryResponse {
    pageInfo?: Paging;
    objects?: Department[] | undefined;
}

export class SentryMaintenanceRecord implements ISentryMaintenanceRecord {
    itemID?: number;
    sentryGUID?: string | undefined;
    time?: number;
    event?: number;
    fixDetail?: string | undefined;
    maintenanceDetail?: string | undefined;

    constructor(data?: ISentryMaintenanceRecord) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.itemID = _data["itemID"];
            this.sentryGUID = _data["sentryGUID"];
            this.time = _data["time"];
            this.event = _data["event"];
            this.fixDetail = _data["fixDetail"];
            this.maintenanceDetail = _data["maintenanceDetail"];
        }
    }

    static fromJS(data: any): SentryMaintenanceRecord {
        data = typeof data === 'object' ? data : {};
        let result = new SentryMaintenanceRecord();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["itemID"] = this.itemID;
        data["sentryGUID"] = this.sentryGUID;
        data["time"] = this.time;
        data["event"] = this.event;
        data["fixDetail"] = this.fixDetail;
        data["maintenanceDetail"] = this.maintenanceDetail;
        return data; 
    }
}

export interface ISentryMaintenanceRecord {
    itemID?: number;
    sentryGUID?: string | undefined;
    time?: number;
    event?: number;
    fixDetail?: string | undefined;
    maintenanceDetail?: string | undefined;
}

export class SentryObjectQueryResponse implements ISentryObjectQueryResponse {
    pageInfo?: Paging;
    objects?: SentryMaintenanceRecord[] | undefined;

    constructor(data?: ISentryObjectQueryResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pageInfo = _data["pageInfo"] ? Paging.fromJS(_data["pageInfo"]) : <any>undefined;
            if (Array.isArray(_data["objects"])) {
                this.objects = [] as any;
                for (let item of _data["objects"])
                    this.objects!.push(SentryMaintenanceRecord.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SentryObjectQueryResponse {
        data = typeof data === 'object' ? data : {};
        let result = new SentryObjectQueryResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pageInfo"] = this.pageInfo ? this.pageInfo.toJSON() : <any>undefined;
        if (Array.isArray(this.objects)) {
            data["objects"] = [];
            for (let item of this.objects)
                data["objects"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ISentryObjectQueryResponse {
    pageInfo?: Paging;
    objects?: SentryMaintenanceRecord[] | undefined;
}

export enum RecordOpType {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
}

export class VideoRecordParam implements IVideoRecordParam {
    sentryGuid?: string | undefined;
    opType?: RecordOpType;

    constructor(data?: IVideoRecordParam) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sentryGuid = _data["sentryGuid"];
            this.opType = _data["opType"];
        }
    }

    static fromJS(data: any): VideoRecordParam {
        data = typeof data === 'object' ? data : {};
        let result = new VideoRecordParam();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sentryGuid"] = this.sentryGuid;
        data["opType"] = this.opType;
        return data; 
    }
}

export interface IVideoRecordParam {
    sentryGuid?: string | undefined;
    opType?: RecordOpType;
}

export enum SexType {
    _0 = 0,
    _1 = 1,
}

export enum LicenseType {
    _0 = 0,
}

export enum CertificateType {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
}

export enum PsonRscType {
    _0 = 0,
    _1 = 1,
}

export class PersonRsc implements IPersonRsc {
    guid?: string | undefined;
    type?: PsonRscType;
    index?: number;
    psonGuid?: string | undefined;
    path?: string | undefined;
    reserved?: string | undefined;

    constructor(data?: IPersonRsc) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.guid = _data["guid"];
            this.type = _data["type"];
            this.index = _data["index"];
            this.psonGuid = _data["psonGuid"];
            this.path = _data["path"];
            this.reserved = _data["reserved"];
        }
    }

    static fromJS(data: any): PersonRsc {
        data = typeof data === 'object' ? data : {};
        let result = new PersonRsc();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["guid"] = this.guid;
        data["type"] = this.type;
        data["index"] = this.index;
        data["psonGuid"] = this.psonGuid;
        data["path"] = this.path;
        data["reserved"] = this.reserved;
        return data; 
    }
}

export interface IPersonRsc {
    guid?: string | undefined;
    type?: PsonRscType;
    index?: number;
    psonGuid?: string | undefined;
    path?: string | undefined;
    reserved?: string | undefined;
}

export class Person implements IPerson {
    guid?: string | undefined;
    userGroupID?: number;
    userGroupName?: string | undefined;
    username?: string | undefined;
    realName?: string | undefined;
    nickName?: string | undefined;
    password?: string | undefined;
    sex?: SexType;
    telephone?: string | undefined;
    email?: string | undefined;
    company?: string | undefined;
    department?: string | undefined;
    class?: string | undefined;
    licenseType?: LicenseType;
    licenseNum?: string | undefined;
    certificateType?: CertificateType;
    certificateNum?: string | undefined;
    score?: string | undefined;
    forbidden?: boolean;
    description?: string | undefined;
    editTime?: number;
    deleteTime?: number;
    reserved?: string | undefined;
    rscs?: PersonRsc[] | undefined;

    constructor(data?: IPerson) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.guid = _data["guid"];
            this.userGroupID = _data["userGroupID"];
            this.userGroupName = _data["userGroupName"];
            this.username = _data["username"];
            this.realName = _data["realName"];
            this.nickName = _data["nickName"];
            this.password = _data["password"];
            this.sex = _data["sex"];
            this.telephone = _data["telephone"];
            this.email = _data["email"];
            this.company = _data["company"];
            this.department = _data["department"];
            this.class = _data["class"];
            this.licenseType = _data["licenseType"];
            this.licenseNum = _data["licenseNum"];
            this.certificateType = _data["certificateType"];
            this.certificateNum = _data["certificateNum"];
            this.score = _data["score"];
            this.forbidden = _data["forbidden"];
            this.description = _data["description"];
            this.editTime = _data["editTime"];
            this.deleteTime = _data["deleteTime"];
            this.reserved = _data["reserved"];
            if (Array.isArray(_data["rscs"])) {
                this.rscs = [] as any;
                for (let item of _data["rscs"])
                    this.rscs!.push(PersonRsc.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Person {
        data = typeof data === 'object' ? data : {};
        let result = new Person();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["guid"] = this.guid;
        data["userGroupID"] = this.userGroupID;
        data["userGroupName"] = this.userGroupName;
        data["username"] = this.username;
        data["realName"] = this.realName;
        data["nickName"] = this.nickName;
        data["password"] = this.password;
        data["sex"] = this.sex;
        data["telephone"] = this.telephone;
        data["email"] = this.email;
        data["company"] = this.company;
        data["department"] = this.department;
        data["class"] = this.class;
        data["licenseType"] = this.licenseType;
        data["licenseNum"] = this.licenseNum;
        data["certificateType"] = this.certificateType;
        data["certificateNum"] = this.certificateNum;
        data["score"] = this.score;
        data["forbidden"] = this.forbidden;
        data["description"] = this.description;
        data["editTime"] = this.editTime;
        data["deleteTime"] = this.deleteTime;
        data["reserved"] = this.reserved;
        if (Array.isArray(this.rscs)) {
            data["rscs"] = [];
            for (let item of this.rscs)
                data["rscs"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPerson {
    guid?: string | undefined;
    userGroupID?: number;
    userGroupName?: string | undefined;
    username?: string | undefined;
    realName?: string | undefined;
    nickName?: string | undefined;
    password?: string | undefined;
    sex?: SexType;
    telephone?: string | undefined;
    email?: string | undefined;
    company?: string | undefined;
    department?: string | undefined;
    class?: string | undefined;
    licenseType?: LicenseType;
    licenseNum?: string | undefined;
    certificateType?: CertificateType;
    certificateNum?: string | undefined;
    score?: string | undefined;
    forbidden?: boolean;
    description?: string | undefined;
    editTime?: number;
    deleteTime?: number;
    reserved?: string | undefined;
    rscs?: PersonRsc[] | undefined;
}

export class PersonObjectQueryResponse implements IPersonObjectQueryResponse {
    pageInfo?: Paging;
    objects?: Person[] | undefined;

    constructor(data?: IPersonObjectQueryResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pageInfo = _data["pageInfo"] ? Paging.fromJS(_data["pageInfo"]) : <any>undefined;
            if (Array.isArray(_data["objects"])) {
                this.objects = [] as any;
                for (let item of _data["objects"])
                    this.objects!.push(Person.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PersonObjectQueryResponse {
        data = typeof data === 'object' ? data : {};
        let result = new PersonObjectQueryResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pageInfo"] = this.pageInfo ? this.pageInfo.toJSON() : <any>undefined;
        if (Array.isArray(this.objects)) {
            data["objects"] = [];
            for (let item of this.objects)
                data["objects"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPersonObjectQueryResponse {
    pageInfo?: Paging;
    objects?: Person[] | undefined;
}

export enum TeamIdentity {
    _0 = 0,
    _1 = 1,
}

export class TeamRelPsonDetail implements ITeamRelPsonDetail {
    itemID?: number;
    identity?: TeamIdentity;
    groupGuid?: string | undefined;
    psonGuid?: string | undefined;
    index?: number;
    reserved?: string | undefined;
    pson?: Person;

    constructor(data?: ITeamRelPsonDetail) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.itemID = _data["itemID"];
            this.identity = _data["identity"];
            this.groupGuid = _data["groupGuid"];
            this.psonGuid = _data["psonGuid"];
            this.index = _data["index"];
            this.reserved = _data["reserved"];
            this.pson = _data["pson"] ? Person.fromJS(_data["pson"]) : <any>undefined;
        }
    }

    static fromJS(data: any): TeamRelPsonDetail {
        data = typeof data === 'object' ? data : {};
        let result = new TeamRelPsonDetail();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["itemID"] = this.itemID;
        data["identity"] = this.identity;
        data["groupGuid"] = this.groupGuid;
        data["psonGuid"] = this.psonGuid;
        data["index"] = this.index;
        data["reserved"] = this.reserved;
        data["pson"] = this.pson ? this.pson.toJSON() : <any>undefined;
        return data; 
    }
}

export interface ITeamRelPsonDetail {
    itemID?: number;
    identity?: TeamIdentity;
    groupGuid?: string | undefined;
    psonGuid?: string | undefined;
    index?: number;
    reserved?: string | undefined;
    pson?: Person;
}

export class Team implements ITeam {
    guid?: string | undefined;
    name?: string | undefined;
    city?: string | undefined;
    createTime?: Date;
    editTime?: number;
    description?: string | undefined;
    reserved?: string | undefined;
    relations?: TeamRelPsonDetail[] | undefined;

    constructor(data?: ITeam) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.guid = _data["guid"];
            this.name = _data["name"];
            this.city = _data["city"];
            this.createTime = _data["createTime"] ? new Date(_data["createTime"].toString()) : <any>undefined;
            this.editTime = _data["editTime"];
            this.description = _data["description"];
            this.reserved = _data["reserved"];
            if (Array.isArray(_data["relations"])) {
                this.relations = [] as any;
                for (let item of _data["relations"])
                    this.relations!.push(TeamRelPsonDetail.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Team {
        data = typeof data === 'object' ? data : {};
        let result = new Team();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["guid"] = this.guid;
        data["name"] = this.name;
        data["city"] = this.city;
        data["createTime"] = this.createTime ? this.createTime.toISOString() : <any>undefined;
        data["editTime"] = this.editTime;
        data["description"] = this.description;
        data["reserved"] = this.reserved;
        if (Array.isArray(this.relations)) {
            data["relations"] = [];
            for (let item of this.relations)
                data["relations"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ITeam {
    guid?: string | undefined;
    name?: string | undefined;
    city?: string | undefined;
    createTime?: Date;
    editTime?: number;
    description?: string | undefined;
    reserved?: string | undefined;
    relations?: TeamRelPsonDetail[] | undefined;
}

export class TeamObjectQueryResponse implements ITeamObjectQueryResponse {
    pageInfo?: Paging;
    objects?: Team[] | undefined;

    constructor(data?: ITeamObjectQueryResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pageInfo = _data["pageInfo"] ? Paging.fromJS(_data["pageInfo"]) : <any>undefined;
            if (Array.isArray(_data["objects"])) {
                this.objects = [] as any;
                for (let item of _data["objects"])
                    this.objects!.push(Team.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TeamObjectQueryResponse {
        data = typeof data === 'object' ? data : {};
        let result = new TeamObjectQueryResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pageInfo"] = this.pageInfo ? this.pageInfo.toJSON() : <any>undefined;
        if (Array.isArray(this.objects)) {
            data["objects"] = [];
            for (let item of this.objects)
                data["objects"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ITeamObjectQueryResponse {
    pageInfo?: Paging;
    objects?: Team[] | undefined;
}

export class TeamRelPsons implements ITeamRelPsons {
    teamGuid?: string | undefined;
    relations?: TeamRelPsonDetail[] | undefined;

    constructor(data?: ITeamRelPsons) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.teamGuid = _data["teamGuid"];
            if (Array.isArray(_data["relations"])) {
                this.relations = [] as any;
                for (let item of _data["relations"])
                    this.relations!.push(TeamRelPsonDetail.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TeamRelPsons {
        data = typeof data === 'object' ? data : {};
        let result = new TeamRelPsons();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["teamGuid"] = this.teamGuid;
        if (Array.isArray(this.relations)) {
            data["relations"] = [];
            for (let item of this.relations)
                data["relations"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ITeamRelPsons {
    teamGuid?: string | undefined;
    relations?: TeamRelPsonDetail[] | undefined;
}

export class SentryRelPsonDetail implements ISentryRelPsonDetail {
    id?: number;
    psonGuid?: string | undefined;
    sentryGuid?: string | undefined;
    index?: number;
    reserved?: string | undefined;

    constructor(data?: ISentryRelPsonDetail) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.psonGuid = _data["psonGuid"];
            this.sentryGuid = _data["sentryGuid"];
            this.index = _data["index"];
            this.reserved = _data["reserved"];
        }
    }

    static fromJS(data: any): SentryRelPsonDetail {
        data = typeof data === 'object' ? data : {};
        let result = new SentryRelPsonDetail();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["psonGuid"] = this.psonGuid;
        data["sentryGuid"] = this.sentryGuid;
        data["index"] = this.index;
        data["reserved"] = this.reserved;
        return data; 
    }
}

export interface ISentryRelPsonDetail {
    id?: number;
    psonGuid?: string | undefined;
    sentryGuid?: string | undefined;
    index?: number;
    reserved?: string | undefined;
}

export class PsonRelSentrys implements IPsonRelSentrys {
    psonGuid?: string | undefined;
    relations?: SentryRelPsonDetail[] | undefined;

    constructor(data?: IPsonRelSentrys) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.psonGuid = _data["psonGuid"];
            if (Array.isArray(_data["relations"])) {
                this.relations = [] as any;
                for (let item of _data["relations"])
                    this.relations!.push(SentryRelPsonDetail.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PsonRelSentrys {
        data = typeof data === 'object' ? data : {};
        let result = new PsonRelSentrys();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["psonGuid"] = this.psonGuid;
        if (Array.isArray(this.relations)) {
            data["relations"] = [];
            for (let item of this.relations)
                data["relations"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPsonRelSentrys {
    psonGuid?: string | undefined;
    relations?: SentryRelPsonDetail[] | undefined;
}

export enum SentryStateType {
    _0 = 0,
    _1 = 1,
}

export class StartUpInfo implements IStartUpInfo {
    regNo?: string | undefined;
    taskGuid?: string | undefined;
    batter?: number;
    endurance?: number;
    longitude?: number;
    latitude?: number;
    height?: number;
    altitude?: number;
    timestamp?: number;
    gpsSatellite?: number;
    rtkSatellite?: number;
    dmzSatellite?: number;

    constructor(data?: IStartUpInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.regNo = _data["regNo"];
            this.taskGuid = _data["taskGuid"];
            this.batter = _data["batter"];
            this.endurance = _data["endurance"];
            this.longitude = _data["longitude"];
            this.latitude = _data["latitude"];
            this.height = _data["height"];
            this.altitude = _data["altitude"];
            this.timestamp = _data["timestamp"];
            this.gpsSatellite = _data["gpsSatellite"];
            this.rtkSatellite = _data["rtkSatellite"];
            this.dmzSatellite = _data["dmzSatellite"];
        }
    }

    static fromJS(data: any): StartUpInfo {
        data = typeof data === 'object' ? data : {};
        let result = new StartUpInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["regNo"] = this.regNo;
        data["taskGuid"] = this.taskGuid;
        data["batter"] = this.batter;
        data["endurance"] = this.endurance;
        data["longitude"] = this.longitude;
        data["latitude"] = this.latitude;
        data["height"] = this.height;
        data["altitude"] = this.altitude;
        data["timestamp"] = this.timestamp;
        data["gpsSatellite"] = this.gpsSatellite;
        data["rtkSatellite"] = this.rtkSatellite;
        data["dmzSatellite"] = this.dmzSatellite;
        return data; 
    }
}

export interface IStartUpInfo {
    regNo?: string | undefined;
    taskGuid?: string | undefined;
    batter?: number;
    endurance?: number;
    longitude?: number;
    latitude?: number;
    height?: number;
    altitude?: number;
    timestamp?: number;
    gpsSatellite?: number;
    rtkSatellite?: number;
    dmzSatellite?: number;
}

export enum SentryType {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
}

export enum TaskType {
    _0 = 0,
    _1 = 1,
}

export enum PointType {
    _0 = 0,
    _1 = 1,
}

export enum PointCmdType {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
    _6 = 6,
    _7 = 7,
}

export enum ReferAltType {
    _0 = 0,
    _1 = 1,
}

export class PointInfo implements IPointInfo {
    longitude?: number;
    latitude?: number;
    altitude?: number;
    speed?: number;
    distance?: number;
    remainTime?: number;
    costTime?: number;
    type?: PointType;
    index?: number;
    command?: PointCmdType;
    commandParams?: number[] | undefined;
    referAlt?: ReferAltType;
    description?: string | undefined;

    constructor(data?: IPointInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.longitude = _data["longitude"];
            this.latitude = _data["latitude"];
            this.altitude = _data["altitude"];
            this.speed = _data["speed"];
            this.distance = _data["distance"];
            this.remainTime = _data["remainTime"];
            this.costTime = _data["costTime"];
            this.type = _data["type"];
            this.index = _data["index"];
            this.command = _data["command"];
            if (Array.isArray(_data["commandParams"])) {
                this.commandParams = [] as any;
                for (let item of _data["commandParams"])
                    this.commandParams!.push(item);
            }
            this.referAlt = _data["referAlt"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): PointInfo {
        data = typeof data === 'object' ? data : {};
        let result = new PointInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["longitude"] = this.longitude;
        data["latitude"] = this.latitude;
        data["altitude"] = this.altitude;
        data["speed"] = this.speed;
        data["distance"] = this.distance;
        data["remainTime"] = this.remainTime;
        data["costTime"] = this.costTime;
        data["type"] = this.type;
        data["index"] = this.index;
        data["command"] = this.command;
        if (Array.isArray(this.commandParams)) {
            data["commandParams"] = [];
            for (let item of this.commandParams)
                data["commandParams"].push(item);
        }
        data["referAlt"] = this.referAlt;
        data["description"] = this.description;
        return data; 
    }
}

export interface IPointInfo {
    longitude?: number;
    latitude?: number;
    altitude?: number;
    speed?: number;
    distance?: number;
    remainTime?: number;
    costTime?: number;
    type?: PointType;
    index?: number;
    command?: PointCmdType;
    commandParams?: number[] | undefined;
    referAlt?: ReferAltType;
    description?: string | undefined;
}

export class SentryArea implements ISentryArea {
    guid?: string | undefined;
    name?: string | undefined;
    distance?: number;
    duration?: number;
    points?: PointInfo[] | undefined;
    editTime?: number;
    deleteTime?: number;
    reserved?: string | undefined;

    constructor(data?: ISentryArea) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.guid = _data["guid"];
            this.name = _data["name"];
            this.distance = _data["distance"];
            this.duration = _data["duration"];
            if (Array.isArray(_data["points"])) {
                this.points = [] as any;
                for (let item of _data["points"])
                    this.points!.push(PointInfo.fromJS(item));
            }
            this.editTime = _data["editTime"];
            this.deleteTime = _data["deleteTime"];
            this.reserved = _data["reserved"];
        }
    }

    static fromJS(data: any): SentryArea {
        data = typeof data === 'object' ? data : {};
        let result = new SentryArea();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["guid"] = this.guid;
        data["name"] = this.name;
        data["distance"] = this.distance;
        data["duration"] = this.duration;
        if (Array.isArray(this.points)) {
            data["points"] = [];
            for (let item of this.points)
                data["points"].push(item.toJSON());
        }
        data["editTime"] = this.editTime;
        data["deleteTime"] = this.deleteTime;
        data["reserved"] = this.reserved;
        return data; 
    }
}

export interface ISentryArea {
    guid?: string | undefined;
    name?: string | undefined;
    distance?: number;
    duration?: number;
    points?: PointInfo[] | undefined;
    editTime?: number;
    deleteTime?: number;
    reserved?: string | undefined;
}

export enum InnerApproveStatusType {
    _0 = 0,
    _1 = 1,
    _2 = 2,
}

export enum ApproveStatusType {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
}

export class SentryTask implements ISentryTask {
    guid?: string | undefined;
    name?: string | undefined;
    beginTime?: Date;
    endTime?: Date;
    sentryType?: SentryType;
    taskType?: TaskType;
    beginPoint?: PointInfo;
    endPoint?: PointInfo;
    sentryArea?: SentryArea;
    defenseAreas?: DefenseArea[] | undefined;
    innerApproveStatus?: InnerApproveStatusType;
    innerApproveTime?: number;
    innerApproveResult?: string | undefined;
    approveStatus?: ApproveStatusType;
    approveResult?: string | undefined;
    createTime?: number;
    applyTime?: number;
    approveTime?: number;
    deleteTime?: number;
    description?: string | undefined;
    reserved?: string | undefined;

    constructor(data?: ISentryTask) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.guid = _data["guid"];
            this.name = _data["name"];
            this.beginTime = _data["beginTime"] ? new Date(_data["beginTime"].toString()) : <any>undefined;
            this.endTime = _data["endTime"] ? new Date(_data["endTime"].toString()) : <any>undefined;
            this.sentryType = _data["sentryType"];
            this.taskType = _data["taskType"];
            this.beginPoint = _data["beginPoint"] ? PointInfo.fromJS(_data["beginPoint"]) : <any>undefined;
            this.endPoint = _data["endPoint"] ? PointInfo.fromJS(_data["endPoint"]) : <any>undefined;
            this.sentryArea = _data["sentryArea"] ? SentryArea.fromJS(_data["sentryArea"]) : <any>undefined;
            if (Array.isArray(_data["defenseAreas"])) {
                this.defenseAreas = [] as any;
                for (let item of _data["defenseAreas"])
                    this.defenseAreas!.push(DefenseArea.fromJS(item));
            }
            this.innerApproveStatus = _data["innerApproveStatus"];
            this.innerApproveTime = _data["innerApproveTime"];
            this.innerApproveResult = _data["innerApproveResult"];
            this.approveStatus = _data["approveStatus"];
            this.approveResult = _data["approveResult"];
            this.createTime = _data["createTime"];
            this.applyTime = _data["applyTime"];
            this.approveTime = _data["approveTime"];
            this.deleteTime = _data["deleteTime"];
            this.description = _data["description"];
            this.reserved = _data["reserved"];
        }
    }

    static fromJS(data: any): SentryTask {
        data = typeof data === 'object' ? data : {};
        let result = new SentryTask();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["guid"] = this.guid;
        data["name"] = this.name;
        data["beginTime"] = this.beginTime ? this.beginTime.toISOString() : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toISOString() : <any>undefined;
        data["sentryType"] = this.sentryType;
        data["taskType"] = this.taskType;
        data["beginPoint"] = this.beginPoint ? this.beginPoint.toJSON() : <any>undefined;
        data["endPoint"] = this.endPoint ? this.endPoint.toJSON() : <any>undefined;
        data["sentryArea"] = this.sentryArea ? this.sentryArea.toJSON() : <any>undefined;
        if (Array.isArray(this.defenseAreas)) {
            data["defenseAreas"] = [];
            for (let item of this.defenseAreas)
                data["defenseAreas"].push(item.toJSON());
        }
        data["innerApproveStatus"] = this.innerApproveStatus;
        data["innerApproveTime"] = this.innerApproveTime;
        data["innerApproveResult"] = this.innerApproveResult;
        data["approveStatus"] = this.approveStatus;
        data["approveResult"] = this.approveResult;
        data["createTime"] = this.createTime;
        data["applyTime"] = this.applyTime;
        data["approveTime"] = this.approveTime;
        data["deleteTime"] = this.deleteTime;
        data["description"] = this.description;
        data["reserved"] = this.reserved;
        return data; 
    }
}

export interface ISentryTask {
    guid?: string | undefined;
    name?: string | undefined;
    beginTime?: Date;
    endTime?: Date;
    sentryType?: SentryType;
    taskType?: TaskType;
    beginPoint?: PointInfo;
    endPoint?: PointInfo;
    sentryArea?: SentryArea;
    defenseAreas?: DefenseArea[] | undefined;
    innerApproveStatus?: InnerApproveStatusType;
    innerApproveTime?: number;
    innerApproveResult?: string | undefined;
    approveStatus?: ApproveStatusType;
    approveResult?: string | undefined;
    createTime?: number;
    applyTime?: number;
    approveTime?: number;
    deleteTime?: number;
    description?: string | undefined;
    reserved?: string | undefined;
}

export class SentryStatus implements ISentryStatus {
    sentry?: SentryInfo;
    state?: SentryStateType;
    startUp?: StartUpInfo;
    task?: SentryTask;
    manipulator?: Person;

    constructor(data?: ISentryStatus) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sentry = _data["sentry"] ? SentryInfo.fromJS(_data["sentry"]) : <any>undefined;
            this.state = _data["state"];
            this.startUp = _data["startUp"] ? StartUpInfo.fromJS(_data["startUp"]) : <any>undefined;
            this.task = _data["task"] ? SentryTask.fromJS(_data["task"]) : <any>undefined;
            this.manipulator = _data["manipulator"] ? Person.fromJS(_data["manipulator"]) : <any>undefined;
        }
    }

    static fromJS(data: any): SentryStatus {
        data = typeof data === 'object' ? data : {};
        let result = new SentryStatus();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sentry"] = this.sentry ? this.sentry.toJSON() : <any>undefined;
        data["state"] = this.state;
        data["startUp"] = this.startUp ? this.startUp.toJSON() : <any>undefined;
        data["task"] = this.task ? this.task.toJSON() : <any>undefined;
        data["manipulator"] = this.manipulator ? this.manipulator.toJSON() : <any>undefined;
        return data; 
    }
}

export interface ISentryStatus {
    sentry?: SentryInfo;
    state?: SentryStateType;
    startUp?: StartUpInfo;
    task?: SentryTask;
    manipulator?: Person;
}

export class PsonStatus implements IPsonStatus {
    guid?: string | undefined;
    name?: string | undefined;
    teamNames?: string[] | undefined;
    sentryStatus?: SentryStatus;

    constructor(data?: IPsonStatus) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.guid = _data["guid"];
            this.name = _data["name"];
            if (Array.isArray(_data["teamNames"])) {
                this.teamNames = [] as any;
                for (let item of _data["teamNames"])
                    this.teamNames!.push(item);
            }
            this.sentryStatus = _data["sentryStatus"] ? SentryStatus.fromJS(_data["sentryStatus"]) : <any>undefined;
        }
    }

    static fromJS(data: any): PsonStatus {
        data = typeof data === 'object' ? data : {};
        let result = new PsonStatus();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["guid"] = this.guid;
        data["name"] = this.name;
        if (Array.isArray(this.teamNames)) {
            data["teamNames"] = [];
            for (let item of this.teamNames)
                data["teamNames"].push(item);
        }
        data["sentryStatus"] = this.sentryStatus ? this.sentryStatus.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IPsonStatus {
    guid?: string | undefined;
    name?: string | undefined;
    teamNames?: string[] | undefined;
    sentryStatus?: SentryStatus;
}

export class SentryInfoObjectQueryResponse implements ISentryInfoObjectQueryResponse {
    pageInfo?: Paging;
    objects?: SentryInfo[] | undefined;

    constructor(data?: ISentryInfoObjectQueryResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pageInfo = _data["pageInfo"] ? Paging.fromJS(_data["pageInfo"]) : <any>undefined;
            if (Array.isArray(_data["objects"])) {
                this.objects = [] as any;
                for (let item of _data["objects"])
                    this.objects!.push(SentryInfo.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SentryInfoObjectQueryResponse {
        data = typeof data === 'object' ? data : {};
        let result = new SentryInfoObjectQueryResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pageInfo"] = this.pageInfo ? this.pageInfo.toJSON() : <any>undefined;
        if (Array.isArray(this.objects)) {
            data["objects"] = [];
            for (let item of this.objects)
                data["objects"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ISentryInfoObjectQueryResponse {
    pageInfo?: Paging;
    objects?: SentryInfo[] | undefined;
}

export class SentryRelPsons implements ISentryRelPsons {
    sentryGuid?: string | undefined;
    relations?: SentryRelPsonDetail[] | undefined;

    constructor(data?: ISentryRelPsons) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sentryGuid = _data["sentryGuid"];
            if (Array.isArray(_data["relations"])) {
                this.relations = [] as any;
                for (let item of _data["relations"])
                    this.relations!.push(SentryRelPsonDetail.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SentryRelPsons {
        data = typeof data === 'object' ? data : {};
        let result = new SentryRelPsons();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sentryGuid"] = this.sentryGuid;
        if (Array.isArray(this.relations)) {
            data["relations"] = [];
            for (let item of this.relations)
                data["relations"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ISentryRelPsons {
    sentryGuid?: string | undefined;
    relations?: SentryRelPsonDetail[] | undefined;
}

export enum CtrlOpType {
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
    _6 = 6,
    _7 = 7,
    _8 = 8,
    _9 = 9,
    _10 = 10,
    _11 = 11,
    _12 = 12,
    _13 = 13,
    _14 = 14,
    _15 = 15,
    _16 = 16,
}

export class DevCtrlOpParam implements IDevCtrlOpParam {
    sentryGuid?: string | undefined;
    opType?: CtrlOpType;
    paramJson?: string | undefined;

    constructor(data?: IDevCtrlOpParam) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sentryGuid = _data["sentryGuid"];
            this.opType = _data["opType"];
            this.paramJson = _data["paramJson"];
        }
    }

    static fromJS(data: any): DevCtrlOpParam {
        data = typeof data === 'object' ? data : {};
        let result = new DevCtrlOpParam();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sentryGuid"] = this.sentryGuid;
        data["opType"] = this.opType;
        data["paramJson"] = this.paramJson;
        return data; 
    }
}

export interface IDevCtrlOpParam {
    sentryGuid?: string | undefined;
    opType?: CtrlOpType;
    paramJson?: string | undefined;
}

export class SentryParam implements ISentryParam {
    sentryGuid?: string | undefined;
    paramID?: string | undefined;
    paramIndex?: number;
    paramType?: number;
    paramValue?: string | undefined;

    constructor(data?: ISentryParam) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sentryGuid = _data["sentryGuid"];
            this.paramID = _data["paramID"];
            this.paramIndex = _data["paramIndex"];
            this.paramType = _data["paramType"];
            this.paramValue = _data["paramValue"];
        }
    }

    static fromJS(data: any): SentryParam {
        data = typeof data === 'object' ? data : {};
        let result = new SentryParam();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sentryGuid"] = this.sentryGuid;
        data["paramID"] = this.paramID;
        data["paramIndex"] = this.paramIndex;
        data["paramType"] = this.paramType;
        data["paramValue"] = this.paramValue;
        return data; 
    }
}

export interface ISentryParam {
    sentryGuid?: string | undefined;
    paramID?: string | undefined;
    paramIndex?: number;
    paramType?: number;
    paramValue?: string | undefined;
}

export class SentryParamNormalResponse implements ISentryParamNormalResponse {
    errorcode?: number;
    message?: SentryParam;

    constructor(data?: ISentryParamNormalResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.errorcode = _data["errorcode"];
            this.message = _data["message"] ? SentryParam.fromJS(_data["message"]) : <any>undefined;
        }
    }

    static fromJS(data: any): SentryParamNormalResponse {
        data = typeof data === 'object' ? data : {};
        let result = new SentryParamNormalResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["errorcode"] = this.errorcode;
        data["message"] = this.message ? this.message.toJSON() : <any>undefined;
        return data; 
    }
}

export interface ISentryParamNormalResponse {
    errorcode?: number;
    message?: SentryParam;
}

export class SentryAreaObjectQueryResponse implements ISentryAreaObjectQueryResponse {
    pageInfo?: Paging;
    objects?: SentryArea[] | undefined;

    constructor(data?: ISentryAreaObjectQueryResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pageInfo = _data["pageInfo"] ? Paging.fromJS(_data["pageInfo"]) : <any>undefined;
            if (Array.isArray(_data["objects"])) {
                this.objects = [] as any;
                for (let item of _data["objects"])
                    this.objects!.push(SentryArea.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SentryAreaObjectQueryResponse {
        data = typeof data === 'object' ? data : {};
        let result = new SentryAreaObjectQueryResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pageInfo"] = this.pageInfo ? this.pageInfo.toJSON() : <any>undefined;
        if (Array.isArray(this.objects)) {
            data["objects"] = [];
            for (let item of this.objects)
                data["objects"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ISentryAreaObjectQueryResponse {
    pageInfo?: Paging;
    objects?: SentryArea[] | undefined;
}

export class AssessResult implements IAssessResult {
    result?: number;
    message?: string | undefined;

    constructor(data?: IAssessResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"];
            this.message = _data["message"];
        }
    }

    static fromJS(data: any): AssessResult {
        data = typeof data === 'object' ? data : {};
        let result = new AssessResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result;
        data["message"] = this.message;
        return data; 
    }
}

export interface IAssessResult {
    result?: number;
    message?: string | undefined;
}

export class TaskBeginInfo implements ITaskBeginInfo {
    regNo?: string | undefined;
    taskGuid?: string | undefined;
    batter?: number;
    endurance?: number;
    longitude?: number;
    latitude?: number;
    height?: number;
    altitude?: number;
    timestamp?: number;

    constructor(data?: ITaskBeginInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.regNo = _data["regNo"];
            this.taskGuid = _data["taskGuid"];
            this.batter = _data["batter"];
            this.endurance = _data["endurance"];
            this.longitude = _data["longitude"];
            this.latitude = _data["latitude"];
            this.height = _data["height"];
            this.altitude = _data["altitude"];
            this.timestamp = _data["timestamp"];
        }
    }

    static fromJS(data: any): TaskBeginInfo {
        data = typeof data === 'object' ? data : {};
        let result = new TaskBeginInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["regNo"] = this.regNo;
        data["taskGuid"] = this.taskGuid;
        data["batter"] = this.batter;
        data["endurance"] = this.endurance;
        data["longitude"] = this.longitude;
        data["latitude"] = this.latitude;
        data["height"] = this.height;
        data["altitude"] = this.altitude;
        data["timestamp"] = this.timestamp;
        return data; 
    }
}

export interface ITaskBeginInfo {
    regNo?: string | undefined;
    taskGuid?: string | undefined;
    batter?: number;
    endurance?: number;
    longitude?: number;
    latitude?: number;
    height?: number;
    altitude?: number;
    timestamp?: number;
}

export class TaskEndInfo implements ITaskEndInfo {
    regNo?: string | undefined;

    constructor(data?: ITaskEndInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.regNo = _data["regNo"];
        }
    }

    static fromJS(data: any): TaskEndInfo {
        data = typeof data === 'object' ? data : {};
        let result = new TaskEndInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["regNo"] = this.regNo;
        return data; 
    }
}

export interface ITaskEndInfo {
    regNo?: string | undefined;
}

export class SentryRecord implements ISentryRecord {
    id?: number;
    taskGuid?: string | undefined;
    psonGuid?: string | undefined;
    sentryGuid?: string | undefined;
    beginTime?: number;
    endTime?: number;
    patrolDuration?: number;
    patrolTimes?: number;
    tracePointPath?: string | undefined;
    startUp?: StartUpInfo;
    taskBegin?: TaskBeginInfo;
    taskEnd?: TaskEndInfo;
    media?: number[] | undefined;
    reserved?: string | undefined;
    taskInfo?: SentryTask;
    pson?: Person;
    sentryInfo?: SentryInfo;

    constructor(data?: ISentryRecord) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.taskGuid = _data["taskGuid"];
            this.psonGuid = _data["psonGuid"];
            this.sentryGuid = _data["sentryGuid"];
            this.beginTime = _data["beginTime"];
            this.endTime = _data["endTime"];
            this.patrolDuration = _data["patrolDuration"];
            this.patrolTimes = _data["patrolTimes"];
            this.tracePointPath = _data["tracePointPath"];
            this.startUp = _data["startUp"] ? StartUpInfo.fromJS(_data["startUp"]) : <any>undefined;
            this.taskBegin = _data["taskBegin"] ? TaskBeginInfo.fromJS(_data["taskBegin"]) : <any>undefined;
            this.taskEnd = _data["taskEnd"] ? TaskEndInfo.fromJS(_data["taskEnd"]) : <any>undefined;
            if (Array.isArray(_data["media"])) {
                this.media = [] as any;
                for (let item of _data["media"])
                    this.media!.push(item);
            }
            this.reserved = _data["reserved"];
            this.taskInfo = _data["taskInfo"] ? SentryTask.fromJS(_data["taskInfo"]) : <any>undefined;
            this.pson = _data["pson"] ? Person.fromJS(_data["pson"]) : <any>undefined;
            this.sentryInfo = _data["sentryInfo"] ? SentryInfo.fromJS(_data["sentryInfo"]) : <any>undefined;
        }
    }

    static fromJS(data: any): SentryRecord {
        data = typeof data === 'object' ? data : {};
        let result = new SentryRecord();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["taskGuid"] = this.taskGuid;
        data["psonGuid"] = this.psonGuid;
        data["sentryGuid"] = this.sentryGuid;
        data["beginTime"] = this.beginTime;
        data["endTime"] = this.endTime;
        data["patrolDuration"] = this.patrolDuration;
        data["patrolTimes"] = this.patrolTimes;
        data["tracePointPath"] = this.tracePointPath;
        data["startUp"] = this.startUp ? this.startUp.toJSON() : <any>undefined;
        data["taskBegin"] = this.taskBegin ? this.taskBegin.toJSON() : <any>undefined;
        data["taskEnd"] = this.taskEnd ? this.taskEnd.toJSON() : <any>undefined;
        if (Array.isArray(this.media)) {
            data["media"] = [];
            for (let item of this.media)
                data["media"].push(item);
        }
        data["reserved"] = this.reserved;
        data["taskInfo"] = this.taskInfo ? this.taskInfo.toJSON() : <any>undefined;
        data["pson"] = this.pson ? this.pson.toJSON() : <any>undefined;
        data["sentryInfo"] = this.sentryInfo ? this.sentryInfo.toJSON() : <any>undefined;
        return data; 
    }
}

export interface ISentryRecord {
    id?: number;
    taskGuid?: string | undefined;
    psonGuid?: string | undefined;
    sentryGuid?: string | undefined;
    beginTime?: number;
    endTime?: number;
    patrolDuration?: number;
    patrolTimes?: number;
    tracePointPath?: string | undefined;
    startUp?: StartUpInfo;
    taskBegin?: TaskBeginInfo;
    taskEnd?: TaskEndInfo;
    media?: number[] | undefined;
    reserved?: string | undefined;
    taskInfo?: SentryTask;
    pson?: Person;
    sentryInfo?: SentryInfo;
}

export class SentryRecordObjectQueryResponse implements ISentryRecordObjectQueryResponse {
    pageInfo?: Paging;
    objects?: SentryRecord[] | undefined;

    constructor(data?: ISentryRecordObjectQueryResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pageInfo = _data["pageInfo"] ? Paging.fromJS(_data["pageInfo"]) : <any>undefined;
            if (Array.isArray(_data["objects"])) {
                this.objects = [] as any;
                for (let item of _data["objects"])
                    this.objects!.push(SentryRecord.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SentryRecordObjectQueryResponse {
        data = typeof data === 'object' ? data : {};
        let result = new SentryRecordObjectQueryResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pageInfo"] = this.pageInfo ? this.pageInfo.toJSON() : <any>undefined;
        if (Array.isArray(this.objects)) {
            data["objects"] = [];
            for (let item of this.objects)
                data["objects"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ISentryRecordObjectQueryResponse {
    pageInfo?: Paging;
    objects?: SentryRecord[] | undefined;
}

export class ByteDataInfo implements IByteDataInfo {
    dataLen?: number;
    datas?: string | undefined;

    constructor(data?: IByteDataInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.dataLen = _data["dataLen"];
            this.datas = _data["datas"];
        }
    }

    static fromJS(data: any): ByteDataInfo {
        data = typeof data === 'object' ? data : {};
        let result = new ByteDataInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dataLen"] = this.dataLen;
        data["datas"] = this.datas;
        return data; 
    }
}

export interface IByteDataInfo {
    dataLen?: number;
    datas?: string | undefined;
}

export enum MediaType {
    _0 = 0,
    _1 = 1,
}

export class MediaRecord implements IMediaRecord {
    id?: number;
    name?: string | undefined;
    tag?: string | undefined;
    type?: MediaType;
    createTime?: number;
    duration?: number;
    size?: number;
    path?: string | undefined;

    constructor(data?: IMediaRecord) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.tag = _data["tag"];
            this.type = _data["type"];
            this.createTime = _data["createTime"];
            this.duration = _data["duration"];
            this.size = _data["size"];
            this.path = _data["path"];
        }
    }

    static fromJS(data: any): MediaRecord {
        data = typeof data === 'object' ? data : {};
        let result = new MediaRecord();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["tag"] = this.tag;
        data["type"] = this.type;
        data["createTime"] = this.createTime;
        data["duration"] = this.duration;
        data["size"] = this.size;
        data["path"] = this.path;
        return data; 
    }
}

export interface IMediaRecord {
    id?: number;
    name?: string | undefined;
    tag?: string | undefined;
    type?: MediaType;
    createTime?: number;
    duration?: number;
    size?: number;
    path?: string | undefined;
}

export class SentryRecordDetail implements ISentryRecordDetail {
    recordInfo?: SentryRecord;
    mediaRecords?: MediaRecord[] | undefined;
    ctrlRecords?: CtrlRecord[] | undefined;

    constructor(data?: ISentryRecordDetail) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.recordInfo = _data["recordInfo"] ? SentryRecord.fromJS(_data["recordInfo"]) : <any>undefined;
            if (Array.isArray(_data["mediaRecords"])) {
                this.mediaRecords = [] as any;
                for (let item of _data["mediaRecords"])
                    this.mediaRecords!.push(MediaRecord.fromJS(item));
            }
            if (Array.isArray(_data["ctrlRecords"])) {
                this.ctrlRecords = [] as any;
                for (let item of _data["ctrlRecords"])
                    this.ctrlRecords!.push(CtrlRecord.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SentryRecordDetail {
        data = typeof data === 'object' ? data : {};
        let result = new SentryRecordDetail();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["recordInfo"] = this.recordInfo ? this.recordInfo.toJSON() : <any>undefined;
        if (Array.isArray(this.mediaRecords)) {
            data["mediaRecords"] = [];
            for (let item of this.mediaRecords)
                data["mediaRecords"].push(item.toJSON());
        }
        if (Array.isArray(this.ctrlRecords)) {
            data["ctrlRecords"] = [];
            for (let item of this.ctrlRecords)
                data["ctrlRecords"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ISentryRecordDetail {
    recordInfo?: SentryRecord;
    mediaRecords?: MediaRecord[] | undefined;
    ctrlRecords?: CtrlRecord[] | undefined;
}

export class SentryRecordDetailObjectQueryResponse implements ISentryRecordDetailObjectQueryResponse {
    pageInfo?: Paging;
    objects?: SentryRecordDetail[] | undefined;

    constructor(data?: ISentryRecordDetailObjectQueryResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pageInfo = _data["pageInfo"] ? Paging.fromJS(_data["pageInfo"]) : <any>undefined;
            if (Array.isArray(_data["objects"])) {
                this.objects = [] as any;
                for (let item of _data["objects"])
                    this.objects!.push(SentryRecordDetail.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SentryRecordDetailObjectQueryResponse {
        data = typeof data === 'object' ? data : {};
        let result = new SentryRecordDetailObjectQueryResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pageInfo"] = this.pageInfo ? this.pageInfo.toJSON() : <any>undefined;
        if (Array.isArray(this.objects)) {
            data["objects"] = [];
            for (let item of this.objects)
                data["objects"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ISentryRecordDetailObjectQueryResponse {
    pageInfo?: Paging;
    objects?: SentryRecordDetail[] | undefined;
}

export class SentryTaskObjectQueryResponse implements ISentryTaskObjectQueryResponse {
    pageInfo?: Paging;
    objects?: SentryTask[] | undefined;

    constructor(data?: ISentryTaskObjectQueryResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pageInfo = _data["pageInfo"] ? Paging.fromJS(_data["pageInfo"]) : <any>undefined;
            if (Array.isArray(_data["objects"])) {
                this.objects = [] as any;
                for (let item of _data["objects"])
                    this.objects!.push(SentryTask.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SentryTaskObjectQueryResponse {
        data = typeof data === 'object' ? data : {};
        let result = new SentryTaskObjectQueryResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pageInfo"] = this.pageInfo ? this.pageInfo.toJSON() : <any>undefined;
        if (Array.isArray(this.objects)) {
            data["objects"] = [];
            for (let item of this.objects)
                data["objects"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ISentryTaskObjectQueryResponse {
    pageInfo?: Paging;
    objects?: SentryTask[] | undefined;
}

export enum IssueStatusType {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
}

export class SentryTaskStatus implements ISentryTaskStatus {
    id?: number;
    sentryGuid?: string | undefined;
    taskGuid?: string | undefined;
    psonGuid?: string | undefined;
    status?: IssueStatusType;
    reserved?: string | undefined;
    sentryInfo?: SentryInfo;
    taskInfo?: SentryTask;

    constructor(data?: ISentryTaskStatus) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.sentryGuid = _data["sentryGuid"];
            this.taskGuid = _data["taskGuid"];
            this.psonGuid = _data["psonGuid"];
            this.status = _data["status"];
            this.reserved = _data["reserved"];
            this.sentryInfo = _data["sentryInfo"] ? SentryInfo.fromJS(_data["sentryInfo"]) : <any>undefined;
            this.taskInfo = _data["taskInfo"] ? SentryTask.fromJS(_data["taskInfo"]) : <any>undefined;
        }
    }

    static fromJS(data: any): SentryTaskStatus {
        data = typeof data === 'object' ? data : {};
        let result = new SentryTaskStatus();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["sentryGuid"] = this.sentryGuid;
        data["taskGuid"] = this.taskGuid;
        data["psonGuid"] = this.psonGuid;
        data["status"] = this.status;
        data["reserved"] = this.reserved;
        data["sentryInfo"] = this.sentryInfo ? this.sentryInfo.toJSON() : <any>undefined;
        data["taskInfo"] = this.taskInfo ? this.taskInfo.toJSON() : <any>undefined;
        return data; 
    }
}

export interface ISentryTaskStatus {
    id?: number;
    sentryGuid?: string | undefined;
    taskGuid?: string | undefined;
    psonGuid?: string | undefined;
    status?: IssueStatusType;
    reserved?: string | undefined;
    sentryInfo?: SentryInfo;
    taskInfo?: SentryTask;
}

export class SentryTaskStatusObjectQueryResponse implements ISentryTaskStatusObjectQueryResponse {
    pageInfo?: Paging;
    objects?: SentryTaskStatus[] | undefined;

    constructor(data?: ISentryTaskStatusObjectQueryResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pageInfo = _data["pageInfo"] ? Paging.fromJS(_data["pageInfo"]) : <any>undefined;
            if (Array.isArray(_data["objects"])) {
                this.objects = [] as any;
                for (let item of _data["objects"])
                    this.objects!.push(SentryTaskStatus.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SentryTaskStatusObjectQueryResponse {
        data = typeof data === 'object' ? data : {};
        let result = new SentryTaskStatusObjectQueryResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pageInfo"] = this.pageInfo ? this.pageInfo.toJSON() : <any>undefined;
        if (Array.isArray(this.objects)) {
            data["objects"] = [];
            for (let item of this.objects)
                data["objects"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ISentryTaskStatusObjectQueryResponse {
    pageInfo?: Paging;
    objects?: SentryTaskStatus[] | undefined;
}

export class WeatherInfo implements IWeatherInfo {
    cityName?: string | undefined;
    tempH?: string | undefined;
    tempL?: string | undefined;
    weather?: string | undefined;
    windDirection?: string | undefined;
    windSpeed?: string | undefined;

    constructor(data?: IWeatherInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.cityName = _data["cityName"];
            this.tempH = _data["tempH"];
            this.tempL = _data["tempL"];
            this.weather = _data["weather"];
            this.windDirection = _data["windDirection"];
            this.windSpeed = _data["windSpeed"];
        }
    }

    static fromJS(data: any): WeatherInfo {
        data = typeof data === 'object' ? data : {};
        let result = new WeatherInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cityName"] = this.cityName;
        data["tempH"] = this.tempH;
        data["tempL"] = this.tempL;
        data["weather"] = this.weather;
        data["windDirection"] = this.windDirection;
        data["windSpeed"] = this.windSpeed;
        return data; 
    }
}

export interface IWeatherInfo {
    cityName?: string | undefined;
    tempH?: string | undefined;
    tempL?: string | undefined;
    weather?: string | undefined;
    windDirection?: string | undefined;
    windSpeed?: string | undefined;
}

export enum IssueOpType {
    _0 = 0,
    _1 = 1,
    _2 = 2,
}

export class TaskIssueParam implements ITaskIssueParam {
    opType?: IssueOpType;
    taskGuid?: string | undefined;
    sentryGuid?: string | undefined;
    psonGuid?: string | undefined;

    constructor(data?: ITaskIssueParam) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.opType = _data["opType"];
            this.taskGuid = _data["taskGuid"];
            this.sentryGuid = _data["sentryGuid"];
            this.psonGuid = _data["psonGuid"];
        }
    }

    static fromJS(data: any): TaskIssueParam {
        data = typeof data === 'object' ? data : {};
        let result = new TaskIssueParam();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["opType"] = this.opType;
        data["taskGuid"] = this.taskGuid;
        data["sentryGuid"] = this.sentryGuid;
        data["psonGuid"] = this.psonGuid;
        return data; 
    }
}

export interface ITaskIssueParam {
    opType?: IssueOpType;
    taskGuid?: string | undefined;
    sentryGuid?: string | undefined;
    psonGuid?: string | undefined;
}

export enum ApproveOpType {
    _0 = 0,
    _1 = 1,
}

export class TaskApproveParam implements ITaskApproveParam {
    opType?: ApproveOpType;
    taskGuid?: string | undefined;

    constructor(data?: ITaskApproveParam) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.opType = _data["opType"];
            this.taskGuid = _data["taskGuid"];
        }
    }

    static fromJS(data: any): TaskApproveParam {
        data = typeof data === 'object' ? data : {};
        let result = new TaskApproveParam();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["opType"] = this.opType;
        data["taskGuid"] = this.taskGuid;
        return data; 
    }
}

export interface ITaskApproveParam {
    opType?: ApproveOpType;
    taskGuid?: string | undefined;
}

export enum InnerApproveResult {
    _0 = 0,
    _1 = 1,
}

export class TaskInnerApproveRst implements ITaskInnerApproveRst {
    approveResult?: InnerApproveResult;
    approveMessage?: string | undefined;
    taskGuid?: string | undefined;

    constructor(data?: ITaskInnerApproveRst) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.approveResult = _data["approveResult"];
            this.approveMessage = _data["approveMessage"];
            this.taskGuid = _data["taskGuid"];
        }
    }

    static fromJS(data: any): TaskInnerApproveRst {
        data = typeof data === 'object' ? data : {};
        let result = new TaskInnerApproveRst();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["approveResult"] = this.approveResult;
        data["approveMessage"] = this.approveMessage;
        data["taskGuid"] = this.taskGuid;
        return data; 
    }
}

export interface ITaskInnerApproveRst {
    approveResult?: InnerApproveResult;
    approveMessage?: string | undefined;
    taskGuid?: string | undefined;
}

export class PerformanceRecord implements IPerformanceRecord {
    cpuUsed?: number;
    memUsed?: number;
    netUsed?: number;
    recordTime?: Date;

    constructor(data?: IPerformanceRecord) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.cpuUsed = _data["cpuUsed"];
            this.memUsed = _data["memUsed"];
            this.netUsed = _data["netUsed"];
            this.recordTime = _data["recordTime"] ? new Date(_data["recordTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): PerformanceRecord {
        data = typeof data === 'object' ? data : {};
        let result = new PerformanceRecord();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cpuUsed"] = this.cpuUsed;
        data["memUsed"] = this.memUsed;
        data["netUsed"] = this.netUsed;
        data["recordTime"] = this.recordTime ? this.recordTime.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IPerformanceRecord {
    cpuUsed?: number;
    memUsed?: number;
    netUsed?: number;
    recordTime?: Date;
}

export class PerformanceRecordObjectQueryResponse implements IPerformanceRecordObjectQueryResponse {
    pageInfo?: Paging;
    objects?: PerformanceRecord[] | undefined;

    constructor(data?: IPerformanceRecordObjectQueryResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pageInfo = _data["pageInfo"] ? Paging.fromJS(_data["pageInfo"]) : <any>undefined;
            if (Array.isArray(_data["objects"])) {
                this.objects = [] as any;
                for (let item of _data["objects"])
                    this.objects!.push(PerformanceRecord.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PerformanceRecordObjectQueryResponse {
        data = typeof data === 'object' ? data : {};
        let result = new PerformanceRecordObjectQueryResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pageInfo"] = this.pageInfo ? this.pageInfo.toJSON() : <any>undefined;
        if (Array.isArray(this.objects)) {
            data["objects"] = [];
            for (let item of this.objects)
                data["objects"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPerformanceRecordObjectQueryResponse {
    pageInfo?: Paging;
    objects?: PerformanceRecord[] | undefined;
}

export enum SentryObjectDimension {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
}

export class StatisticRequest implements IStatisticRequest {
    startTime?: Date;
    endTime?: Date;
    objectDimesion?: SentryObjectDimension;

    constructor(data?: IStatisticRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.startTime = _data["startTime"] ? new Date(_data["startTime"].toString()) : <any>undefined;
            this.endTime = _data["endTime"] ? new Date(_data["endTime"].toString()) : <any>undefined;
            this.objectDimesion = _data["objectDimesion"];
        }
    }

    static fromJS(data: any): StatisticRequest {
        data = typeof data === 'object' ? data : {};
        let result = new StatisticRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toISOString() : <any>undefined;
        data["objectDimesion"] = this.objectDimesion;
        return data; 
    }
}

export interface IStatisticRequest {
    startTime?: Date;
    endTime?: Date;
    objectDimesion?: SentryObjectDimension;
}

export class TypeCountPair implements ITypeCountPair {
    type?: number;
    count?: number;

    constructor(data?: ITypeCountPair) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.count = _data["count"];
        }
    }

    static fromJS(data: any): TypeCountPair {
        data = typeof data === 'object' ? data : {};
        let result = new TypeCountPair();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["count"] = this.count;
        return data; 
    }
}

export interface ITypeCountPair {
    type?: number;
    count?: number;
}

export class CountStatisticResult implements ICountStatisticResult {
    name?: string | undefined;
    infos?: TypeCountPair[] | undefined;

    constructor(data?: ICountStatisticResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            if (Array.isArray(_data["infos"])) {
                this.infos = [] as any;
                for (let item of _data["infos"])
                    this.infos!.push(TypeCountPair.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CountStatisticResult {
        data = typeof data === 'object' ? data : {};
        let result = new CountStatisticResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        if (Array.isArray(this.infos)) {
            data["infos"] = [];
            for (let item of this.infos)
                data["infos"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ICountStatisticResult {
    name?: string | undefined;
    infos?: TypeCountPair[] | undefined;
}

export class DutyDurationStatistic implements IDutyDurationStatistic {
    name?: string | undefined;
    duration?: number;

    constructor(data?: IDutyDurationStatistic) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.duration = _data["duration"];
        }
    }

    static fromJS(data: any): DutyDurationStatistic {
        data = typeof data === 'object' ? data : {};
        let result = new DutyDurationStatistic();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["duration"] = this.duration;
        return data; 
    }
}

export interface IDutyDurationStatistic {
    name?: string | undefined;
    duration?: number;
}

export class SentryEventStatistic implements ISentryEventStatistic {
    name?: string | undefined;
    times?: number;

    constructor(data?: ISentryEventStatistic) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.times = _data["times"];
        }
    }

    static fromJS(data: any): SentryEventStatistic {
        data = typeof data === 'object' ? data : {};
        let result = new SentryEventStatistic();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["times"] = this.times;
        return data; 
    }
}

export interface ISentryEventStatistic {
    name?: string | undefined;
    times?: number;
}

export enum TimeDimension {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
}

export class ObjectStatisticRequest implements IObjectStatisticRequest {
    startTime?: Date;
    endTime?: Date;
    timeDimension?: TimeDimension;
    objectType?: SentryObjectDimension;
    objectGUID?: string | undefined;

    constructor(data?: IObjectStatisticRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.startTime = _data["startTime"] ? new Date(_data["startTime"].toString()) : <any>undefined;
            this.endTime = _data["endTime"] ? new Date(_data["endTime"].toString()) : <any>undefined;
            this.timeDimension = _data["timeDimension"];
            this.objectType = _data["objectType"];
            this.objectGUID = _data["objectGUID"];
        }
    }

    static fromJS(data: any): ObjectStatisticRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ObjectStatisticRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toISOString() : <any>undefined;
        data["timeDimension"] = this.timeDimension;
        data["objectType"] = this.objectType;
        data["objectGUID"] = this.objectGUID;
        return data; 
    }
}

export interface IObjectStatisticRequest {
    startTime?: Date;
    endTime?: Date;
    timeDimension?: TimeDimension;
    objectType?: SentryObjectDimension;
    objectGUID?: string | undefined;
}

export class EventAndDurarionDetail implements IEventAndDurarionDetail {
    event?: number;
    duration?: number;
    date?: string | undefined;
    time?: string | undefined;

    constructor(data?: IEventAndDurarionDetail) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.event = _data["event"];
            this.duration = _data["duration"];
            this.date = _data["date"];
            this.time = _data["time"];
        }
    }

    static fromJS(data: any): EventAndDurarionDetail {
        data = typeof data === 'object' ? data : {};
        let result = new EventAndDurarionDetail();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["event"] = this.event;
        data["duration"] = this.duration;
        data["date"] = this.date;
        data["time"] = this.time;
        return data; 
    }
}

export interface IEventAndDurarionDetail {
    event?: number;
    duration?: number;
    date?: string | undefined;
    time?: string | undefined;
}

export class SingleSentryStatisticResponse implements ISingleSentryStatisticResponse {
    event?: number;
    duration?: number;
    totalCount?: number;
    involationCount?: number;
    warnningCount?: number;
    recordingDuration?: number;
    recordingSize?: number;
    snapCount?: number;
    snapSize?: number;
    infos?: EventAndDurarionDetail[] | undefined;

    constructor(data?: ISingleSentryStatisticResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.event = _data["event"];
            this.duration = _data["duration"];
            this.totalCount = _data["totalCount"];
            this.involationCount = _data["involationCount"];
            this.warnningCount = _data["warnningCount"];
            this.recordingDuration = _data["recordingDuration"];
            this.recordingSize = _data["recordingSize"];
            this.snapCount = _data["snapCount"];
            this.snapSize = _data["snapSize"];
            if (Array.isArray(_data["infos"])) {
                this.infos = [] as any;
                for (let item of _data["infos"])
                    this.infos!.push(EventAndDurarionDetail.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SingleSentryStatisticResponse {
        data = typeof data === 'object' ? data : {};
        let result = new SingleSentryStatisticResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["event"] = this.event;
        data["duration"] = this.duration;
        data["totalCount"] = this.totalCount;
        data["involationCount"] = this.involationCount;
        data["warnningCount"] = this.warnningCount;
        data["recordingDuration"] = this.recordingDuration;
        data["recordingSize"] = this.recordingSize;
        data["snapCount"] = this.snapCount;
        data["snapSize"] = this.snapSize;
        if (Array.isArray(this.infos)) {
            data["infos"] = [];
            for (let item of this.infos)
                data["infos"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ISingleSentryStatisticResponse {
    event?: number;
    duration?: number;
    totalCount?: number;
    involationCount?: number;
    warnningCount?: number;
    recordingDuration?: number;
    recordingSize?: number;
    snapCount?: number;
    snapSize?: number;
    infos?: EventAndDurarionDetail[] | undefined;
}

export class DBVersion implements IDBVersion {
    version?: string | undefined;
    createTime?: number;

    constructor(data?: IDBVersion) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.version = _data["version"];
            this.createTime = _data["createTime"];
        }
    }

    static fromJS(data: any): DBVersion {
        data = typeof data === 'object' ? data : {};
        let result = new DBVersion();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["version"] = this.version;
        data["createTime"] = this.createTime;
        return data; 
    }
}

export interface IDBVersion {
    version?: string | undefined;
    createTime?: number;
}

export class SysCfg implements ISysCfg {
    paramGroup?: string | undefined;
    paramKey?: string | undefined;
    paramValue?: string | undefined;
    editTime?: number;
    reserved?: string | undefined;

    constructor(data?: ISysCfg) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.paramGroup = _data["paramGroup"];
            this.paramKey = _data["paramKey"];
            this.paramValue = _data["paramValue"];
            this.editTime = _data["editTime"];
            this.reserved = _data["reserved"];
        }
    }

    static fromJS(data: any): SysCfg {
        data = typeof data === 'object' ? data : {};
        let result = new SysCfg();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["paramGroup"] = this.paramGroup;
        data["paramKey"] = this.paramKey;
        data["paramValue"] = this.paramValue;
        data["editTime"] = this.editTime;
        data["reserved"] = this.reserved;
        return data; 
    }
}

export interface ISysCfg {
    paramGroup?: string | undefined;
    paramKey?: string | undefined;
    paramValue?: string | undefined;
    editTime?: number;
    reserved?: string | undefined;
}

export class OpRecord implements IOpRecord {
    id?: number;
    operation?: string | undefined;
    username?: string | undefined;
    userIpAddr?: string | undefined;
    occurTime?: Date;
    opResult?: boolean;
    description?: string | undefined;

    constructor(data?: IOpRecord) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.operation = _data["operation"];
            this.username = _data["username"];
            this.userIpAddr = _data["userIpAddr"];
            this.occurTime = _data["occurTime"] ? new Date(_data["occurTime"].toString()) : <any>undefined;
            this.opResult = _data["opResult"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): OpRecord {
        data = typeof data === 'object' ? data : {};
        let result = new OpRecord();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["operation"] = this.operation;
        data["username"] = this.username;
        data["userIpAddr"] = this.userIpAddr;
        data["occurTime"] = this.occurTime ? this.occurTime.toISOString() : <any>undefined;
        data["opResult"] = this.opResult;
        data["description"] = this.description;
        return data; 
    }
}

export interface IOpRecord {
    id?: number;
    operation?: string | undefined;
    username?: string | undefined;
    userIpAddr?: string | undefined;
    occurTime?: Date;
    opResult?: boolean;
    description?: string | undefined;
}

export class OpRecordObjectQueryResponse implements IOpRecordObjectQueryResponse {
    pageInfo?: Paging;
    objects?: OpRecord[] | undefined;

    constructor(data?: IOpRecordObjectQueryResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pageInfo = _data["pageInfo"] ? Paging.fromJS(_data["pageInfo"]) : <any>undefined;
            if (Array.isArray(_data["objects"])) {
                this.objects = [] as any;
                for (let item of _data["objects"])
                    this.objects!.push(OpRecord.fromJS(item));
            }
        }
    }

    static fromJS(data: any): OpRecordObjectQueryResponse {
        data = typeof data === 'object' ? data : {};
        let result = new OpRecordObjectQueryResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pageInfo"] = this.pageInfo ? this.pageInfo.toJSON() : <any>undefined;
        if (Array.isArray(this.objects)) {
            data["objects"] = [];
            for (let item of this.objects)
                data["objects"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IOpRecordObjectQueryResponse {
    pageInfo?: Paging;
    objects?: OpRecord[] | undefined;
}

export enum FileDataType {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
}

export class UploadFileParam implements IUploadFileParam {
    fileType?: FileDataType;
    datas?: string | undefined;

    constructor(data?: IUploadFileParam) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fileType = _data["fileType"];
            this.datas = _data["datas"];
        }
    }

    static fromJS(data: any): UploadFileParam {
        data = typeof data === 'object' ? data : {};
        let result = new UploadFileParam();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fileType"] = this.fileType;
        data["datas"] = this.datas;
        return data; 
    }
}

export interface IUploadFileParam {
    fileType?: FileDataType;
    datas?: string | undefined;
}

export class DownloadFileParam implements IDownloadFileParam {
    rscType?: FileDataType;
    rscGuid?: string | undefined;

    constructor(data?: IDownloadFileParam) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.rscType = _data["rscType"];
            this.rscGuid = _data["rscGuid"];
        }
    }

    static fromJS(data: any): DownloadFileParam {
        data = typeof data === 'object' ? data : {};
        let result = new DownloadFileParam();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["rscType"] = this.rscType;
        data["rscGuid"] = this.rscGuid;
        return data; 
    }
}

export interface IDownloadFileParam {
    rscType?: FileDataType;
    rscGuid?: string | undefined;
}

export class UserGroup implements IUserGroup {
    id?: number;
    name?: string | undefined;
    power?: string[] | undefined;
    reserved?: string | undefined;

    constructor(data?: IUserGroup) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            if (Array.isArray(_data["power"])) {
                this.power = [] as any;
                for (let item of _data["power"])
                    this.power!.push(item);
            }
            this.reserved = _data["reserved"];
        }
    }

    static fromJS(data: any): UserGroup {
        data = typeof data === 'object' ? data : {};
        let result = new UserGroup();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        if (Array.isArray(this.power)) {
            data["power"] = [];
            for (let item of this.power)
                data["power"].push(item);
        }
        data["reserved"] = this.reserved;
        return data; 
    }
}

export interface IUserGroup {
    id?: number;
    name?: string | undefined;
    power?: string[] | undefined;
    reserved?: string | undefined;
}

export class UserGroupObjectQueryResponse implements IUserGroupObjectQueryResponse {
    pageInfo?: Paging;
    objects?: UserGroup[] | undefined;

    constructor(data?: IUserGroupObjectQueryResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pageInfo = _data["pageInfo"] ? Paging.fromJS(_data["pageInfo"]) : <any>undefined;
            if (Array.isArray(_data["objects"])) {
                this.objects = [] as any;
                for (let item of _data["objects"])
                    this.objects!.push(UserGroup.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UserGroupObjectQueryResponse {
        data = typeof data === 'object' ? data : {};
        let result = new UserGroupObjectQueryResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pageInfo"] = this.pageInfo ? this.pageInfo.toJSON() : <any>undefined;
        if (Array.isArray(this.objects)) {
            data["objects"] = [];
            for (let item of this.objects)
                data["objects"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IUserGroupObjectQueryResponse {
    pageInfo?: Paging;
    objects?: UserGroup[] | undefined;
}

export class WeatherReqInfo implements IWeatherReqInfo {
    longitude?: number;
    latitude?: number;
    timeDms?: number;
    duration?: number;

    constructor(data?: IWeatherReqInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.longitude = _data["longitude"];
            this.latitude = _data["latitude"];
            this.timeDms = _data["timeDms"];
            this.duration = _data["duration"];
        }
    }

    static fromJS(data: any): WeatherReqInfo {
        data = typeof data === 'object' ? data : {};
        let result = new WeatherReqInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["longitude"] = this.longitude;
        data["latitude"] = this.latitude;
        data["timeDms"] = this.timeDms;
        data["duration"] = this.duration;
        return data; 
    }
}

export interface IWeatherReqInfo {
    longitude?: number;
    latitude?: number;
    timeDms?: number;
    duration?: number;
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}
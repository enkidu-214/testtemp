/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.14.8.0 (NJsonSchema v10.5.2.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming
import { BaseClass } from "./BaseClass"

export class STCSClient extends BaseClass {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    addOrUpdateImportantDataInfo(info: MapImportantDataInfo): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/STCS/AddOrUpdateImportantDataInfo";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(info);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processAddOrUpdateImportantDataInfo(_response);
        });
    }

    protected processAddOrUpdateImportantDataInfo(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    delImportantDataInfo(itemID: number | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/STCS/DelImportantDataInfo?";
        if (itemID === null)
            throw new Error("The parameter 'itemID' cannot be null.");
        else if (itemID !== undefined)
            url_ += "itemID=" + encodeURIComponent("" + itemID) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDelImportantDataInfo(_response);
        });
    }

    protected processDelImportantDataInfo(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    queryImportantDataInfo(): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/STCS/QueryImportantDataInfo";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processQueryImportantDataInfo(_response);
        });
    }

    protected processQueryImportantDataInfo(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    addOrUpdateAlarmTypeInfo(typeInfo: AlarmTypeInfo): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/STCS/AddOrUpdateAlarmTypeInfo";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(typeInfo);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processAddOrUpdateAlarmTypeInfo(_response);
        });
    }

    protected processAddOrUpdateAlarmTypeInfo(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    delAlarmTypeInfo(itemID: number | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/STCS/DelAlarmTypeInfo?";
        if (itemID === null)
            throw new Error("The parameter 'itemID' cannot be null.");
        else if (itemID !== undefined)
            url_ += "itemID=" + encodeURIComponent("" + itemID) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDelAlarmTypeInfo(_response);
        });
    }

    protected processDelAlarmTypeInfo(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    queryAlarmTypeInfo(): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/STCS/QueryAlarmTypeInfo";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processQueryAlarmTypeInfo(_response);
        });
    }

    protected processQueryAlarmTypeInfo(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    addOrUpdatePreSchemeInfo(info: AlarmSchemeInfo): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/STCS/AddOrUpdatePreSchemeInfo";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(info);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processAddOrUpdatePreSchemeInfo(_response);
        });
    }

    protected processAddOrUpdatePreSchemeInfo(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    delPreSchemeInfo(preSchemeID: number | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/STCS/DelPreSchemeInfo?";
        if (preSchemeID === null)
            throw new Error("The parameter 'preSchemeID' cannot be null.");
        else if (preSchemeID !== undefined)
            url_ += "preSchemeID=" + encodeURIComponent("" + preSchemeID) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDelPreSchemeInfo(_response);
        });
    }

    protected processDelPreSchemeInfo(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    queryPreSchemeInfo(): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/STCS/QueryPreSchemeInfo";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processQueryPreSchemeInfo(_response);
        });
    }

    protected processQueryPreSchemeInfo(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    confPreSchemeItemInfo(alarmSchemeID: number | undefined, info: AlarmSchemeItem[]): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/STCS/ConfPreSchemeItemInfo?";
        if (alarmSchemeID === null)
            throw new Error("The parameter 'alarmSchemeID' cannot be null.");
        else if (alarmSchemeID !== undefined)
            url_ += "alarmSchemeID=" + encodeURIComponent("" + alarmSchemeID) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(info);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processConfPreSchemeItemInfo(_response);
        });
    }

    protected processConfPreSchemeItemInfo(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    queryPreSchemeItemInfo(schemeID: number | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/STCS/QueryPreSchemeItemInfo?";
        if (schemeID === null)
            throw new Error("The parameter 'schemeID' cannot be null.");
        else if (schemeID !== undefined)
            url_ += "schemeID=" + encodeURIComponent("" + schemeID) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processQueryPreSchemeItemInfo(_response);
        });
    }

    protected processQueryPreSchemeItemInfo(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    configAlarmSrcRelAlarmType(alarmSourceID: number | undefined, conf: AlarmSourceRelTypeInfo[]): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/STCS/ConfigAlarmSrcRelAlarmType?";
        if (alarmSourceID === null)
            throw new Error("The parameter 'alarmSourceID' cannot be null.");
        else if (alarmSourceID !== undefined)
            url_ += "AlarmSourceID=" + encodeURIComponent("" + alarmSourceID) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(conf);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processConfigAlarmSrcRelAlarmType(_response);
        });
    }

    protected processConfigAlarmSrcRelAlarmType(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    queryAlarmSrcRelAlarmType(resID: number | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/STCS/QueryAlarmSrcRelAlarmType?";
        if (resID === null)
            throw new Error("The parameter 'resID' cannot be null.");
        else if (resID !== undefined)
            url_ += "resID=" + encodeURIComponent("" + resID) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processQueryAlarmSrcRelAlarmType(_response);
        });
    }

    protected processQueryAlarmSrcRelAlarmType(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    confAlarmLinkageInfo(alarmSourceID: number | undefined, conf: AlarmLinkInfo[]): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/STCS/ConfAlarmLinkageInfo?";
        if (alarmSourceID === null)
            throw new Error("The parameter 'alarmSourceID' cannot be null.");
        else if (alarmSourceID !== undefined)
            url_ += "alarmSourceID=" + encodeURIComponent("" + alarmSourceID) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(conf);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processConfAlarmLinkageInfo(_response);
        });
    }

    protected processConfAlarmLinkageInfo(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    delAlarmLinkageInfo(linkID: number | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/STCS/DelAlarmLinkageInfo?";
        if (linkID === null)
            throw new Error("The parameter 'linkID' cannot be null.");
        else if (linkID !== undefined)
            url_ += "linkID=" + encodeURIComponent("" + linkID) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDelAlarmLinkageInfo(_response);
        });
    }

    protected processDelAlarmLinkageInfo(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    queryAlarmLinkageInfo(rscId: number | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/STCS/QueryAlarmLinkageInfo?";
        if (rscId === null)
            throw new Error("The parameter 'rscId' cannot be null.");
        else if (rscId !== undefined)
            url_ += "rscId=" + encodeURIComponent("" + rscId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processQueryAlarmLinkageInfo(_response);
        });
    }

    protected processQueryAlarmLinkageInfo(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    addOrUpdateDevInfo(devInfo: DeviceInfo): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/STCS/AddOrUpdateDevInfo";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(devInfo);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processAddOrUpdateDevInfo(_response);
        });
    }

    protected processAddOrUpdateDevInfo(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    delDevInfo(devID: number | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/STCS/DelDevInfo?";
        if (devID === null)
            throw new Error("The parameter 'devID' cannot be null.");
        else if (devID !== undefined)
            url_ += "devID=" + encodeURIComponent("" + devID) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDelDevInfo(_response);
        });
    }

    protected processDelDevInfo(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    queryDevInfos(devType: number | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/STCS/QueryDevInfos?";
        if (devType === null)
            throw new Error("The parameter 'devType' cannot be null.");
        else if (devType !== undefined)
            url_ += "devType=" + encodeURIComponent("" + devType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processQueryDevInfos(_response);
        });
    }

    protected processQueryDevInfos(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    queryDevStateInfo(devID: number | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/STCS/QueryDevStateInfo?";
        if (devID === null)
            throw new Error("The parameter 'devID' cannot be null.");
        else if (devID !== undefined)
            url_ += "devID=" + encodeURIComponent("" + devID) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processQueryDevStateInfo(_response);
        });
    }

    protected processQueryDevStateInfo(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    querySubDevInfos(parentID: number | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/STCS/QuerySubDevInfos?";
        if (parentID === null)
            throw new Error("The parameter 'parentID' cannot be null.");
        else if (parentID !== undefined)
            url_ += "parentID=" + encodeURIComponent("" + parentID) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processQuerySubDevInfos(_response);
        });
    }

    protected processQuerySubDevInfos(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    querySubDevStateInfos(parentID: number | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/STCS/QuerySubDevStateInfos?";
        if (parentID === null)
            throw new Error("The parameter 'parentID' cannot be null.");
        else if (parentID !== undefined)
            url_ += "parentID=" + encodeURIComponent("" + parentID) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processQuerySubDevStateInfos(_response);
        });
    }

    protected processQuerySubDevStateInfos(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    queryDevStateInfos(devType: DevType | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/STCS/QueryDevStateInfos?";
        if (devType === null)
            throw new Error("The parameter 'devType' cannot be null.");
        else if (devType !== undefined)
            url_ += "devType=" + encodeURIComponent("" + devType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processQueryDevStateInfos(_response);
        });
    }

    protected processQueryDevStateInfos(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    queryResourceInfo(devId: number | undefined, devType: DevType | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/STCS/QueryResourceInfo?";
        if (devId === null)
            throw new Error("The parameter 'devId' cannot be null.");
        else if (devId !== undefined)
            url_ += "devId=" + encodeURIComponent("" + devId) + "&";
        if (devType === null)
            throw new Error("The parameter 'devType' cannot be null.");
        else if (devType !== undefined)
            url_ += "devType=" + encodeURIComponent("" + devType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processQueryResourceInfo(_response);
        });
    }

    protected processQueryResourceInfo(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    modifyResourceInfo(resourceInfo: ResourceInfo): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/STCS/ModifyResourceInfo";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(resourceInfo);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processModifyResourceInfo(_response);
        });
    }

    protected processModifyResourceInfo(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    confDevRelResInfo(devID: number | undefined, rel: DevRelResourceInfo[]): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/STCS/ConfDevRelResInfo?";
        if (devID === null)
            throw new Error("The parameter 'devID' cannot be null.");
        else if (devID !== undefined)
            url_ += "devID=" + encodeURIComponent("" + devID) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(rel);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processConfDevRelResInfo(_response);
        });
    }

    protected processConfDevRelResInfo(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    queryDevRelResInfos(devID: number | undefined, relType: ResType | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/STCS/QueryDevRelResInfos?";
        if (devID === null)
            throw new Error("The parameter 'devID' cannot be null.");
        else if (devID !== undefined)
            url_ += "devID=" + encodeURIComponent("" + devID) + "&";
        if (relType === null)
            throw new Error("The parameter 'relType' cannot be null.");
        else if (relType !== undefined)
            url_ += "relType=" + encodeURIComponent("" + relType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processQueryDevRelResInfos(_response);
        });
    }

    protected processQueryDevRelResInfos(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    getDeviceCallNums(): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/STCS/GetDeviceCallNums";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetDeviceCallNums(_response);
        });
    }

    protected processGetDeviceCallNums(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    addOrUpdateAudioFileInfo(info: FileData): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/STCS/AddOrUpdateAudioFileInfo";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(info);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processAddOrUpdateAudioFileInfo(_response);
        });
    }

    protected processAddOrUpdateAudioFileInfo(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    delAudioFileInfo(fileName: string | null | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/STCS/DelAudioFileInfo?";
        if (fileName !== undefined && fileName !== null)
            url_ += "fileName=" + encodeURIComponent("" + fileName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDelAudioFileInfo(_response);
        });
    }

    protected processDelAudioFileInfo(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    queryAudioFileInfos(): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/STCS/QueryAudioFileInfos";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processQueryAudioFileInfos(_response);
        });
    }

    protected processQueryAudioFileInfos(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    getDeviceAudioFileInfos(devID: number | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/STCS/GetDeviceAudioFileInfos?";
        if (devID === null)
            throw new Error("The parameter 'devID' cannot be null.");
        else if (devID !== undefined)
            url_ += "devID=" + encodeURIComponent("" + devID) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetDeviceAudioFileInfos(_response);
        });
    }

    protected processGetDeviceAudioFileInfos(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    removeDeviceAudioFileInfos(devID: number | undefined, audios: string[]): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/STCS/RemoveDeviceAudioFileInfos?";
        if (devID === null)
            throw new Error("The parameter 'devID' cannot be null.");
        else if (devID !== undefined)
            url_ += "devID=" + encodeURIComponent("" + devID) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(audios);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processRemoveDeviceAudioFileInfos(_response);
        });
    }

    protected processRemoveDeviceAudioFileInfos(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    queryMidisPreviewInfo(devID: number | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/STCS/QueryMidisPreviewInfo?";
        if (devID === null)
            throw new Error("The parameter 'devID' cannot be null.");
        else if (devID !== undefined)
            url_ += "devID=" + encodeURIComponent("" + devID) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processQueryMidisPreviewInfo(_response);
        });
    }

    protected processQueryMidisPreviewInfo(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    queryCurrentShootingPlan(): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/STCS/QueryCurrentShootingPlan";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processQueryCurrentShootingPlan(_response);
        });
    }

    protected processQueryCurrentShootingPlan(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    queryCurrentShootingInfo(targetIdx: number): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/STCS/QueryCurrentShootingInfo/{targetIdx}";
        if (targetIdx === undefined || targetIdx === null)
            throw new Error("The parameter 'targetIdx' must be defined.");
        url_ = url_.replace("{targetIdx}", encodeURIComponent("" + targetIdx));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processQueryCurrentShootingInfo(_response);
        });
    }

    protected processQueryCurrentShootingInfo(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    queryCurrentShootingResult(targetIdx: number): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/STCS/QueryCurrentShootingResult/{targetIdx}";
        if (targetIdx === undefined || targetIdx === null)
            throw new Error("The parameter 'targetIdx' must be defined.");
        url_ = url_.replace("{targetIdx}", encodeURIComponent("" + targetIdx));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processQueryCurrentShootingResult(_response);
        });
    }

    protected processQueryCurrentShootingResult(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    queryPersonShootingResult(planId: number | undefined, personId: number | undefined, roundIdxIdx: number | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/STCS/QueryPersonShootingResult?";
        if (planId === null)
            throw new Error("The parameter 'planId' cannot be null.");
        else if (planId !== undefined)
            url_ += "planId=" + encodeURIComponent("" + planId) + "&";
        if (personId === null)
            throw new Error("The parameter 'personId' cannot be null.");
        else if (personId !== undefined)
            url_ += "personId=" + encodeURIComponent("" + personId) + "&";
        if (roundIdxIdx === null)
            throw new Error("The parameter 'roundIdxIdx' cannot be null.");
        else if (roundIdxIdx !== undefined)
            url_ += "roundIdxIdx=" + encodeURIComponent("" + roundIdxIdx) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processQueryPersonShootingResult(_response);
        });
    }

    protected processQueryPersonShootingResult(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    queryPersonShootingResultByPlanId(planId: number): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/STCS/QueryPersonShootingResultByPlanId/{planId}";
        if (planId === undefined || planId === null)
            throw new Error("The parameter 'planId' must be defined.");
        url_ = url_.replace("{planId}", encodeURIComponent("" + planId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processQueryPersonShootingResultByPlanId(_response);
        });
    }

    protected processQueryPersonShootingResultByPlanId(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    updateProShootingGunTrack(targetIdx: number | undefined, record: ShootingGunTrackRecord): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/STCS/UpdateProShootingGunTrack?";
        if (targetIdx === null)
            throw new Error("The parameter 'targetIdx' cannot be null.");
        else if (targetIdx !== undefined)
            url_ += "targetIdx=" + encodeURIComponent("" + targetIdx) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(record);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUpdateProShootingGunTrack(_response);
        });
    }

    protected processUpdateProShootingGunTrack(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    queryBraceletDevInfo(braceletDevName: string | null): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/STCS/QueryBraceletDevInfo/{braceletDevName}";
        if (braceletDevName === undefined || braceletDevName === null)
            throw new Error("The parameter 'braceletDevName' must be defined.");
        url_ = url_.replace("{braceletDevName}", encodeURIComponent("" + braceletDevName));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processQueryBraceletDevInfo(_response);
        });
    }

    protected processQueryBraceletDevInfo(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    queryProShootingGunTrack(planId: number | undefined, personID: number | undefined, roundIdx: number | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/STCS/QueryProShootingGunTrack?";
        if (planId === null)
            throw new Error("The parameter 'planId' cannot be null.");
        else if (planId !== undefined)
            url_ += "planId=" + encodeURIComponent("" + planId) + "&";
        if (personID === null)
            throw new Error("The parameter 'personID' cannot be null.");
        else if (personID !== undefined)
            url_ += "personID=" + encodeURIComponent("" + personID) + "&";
        if (roundIdx === null)
            throw new Error("The parameter 'roundIdx' cannot be null.");
        else if (roundIdx !== undefined)
            url_ += "roundIdx=" + encodeURIComponent("" + roundIdx) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processQueryProShootingGunTrack(_response);
        });
    }

    protected processQueryProShootingGunTrack(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    queryShootingPlans(count: number | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/STCS/QueryShootingPlans?";
        if (count === null)
            throw new Error("The parameter 'count' cannot be null.");
        else if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processQueryShootingPlans(_response);
        });
    }

    protected processQueryShootingPlans(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    queryNoRelationShootingPlans(planIds: number[]): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/STCS/QueryNoRelationShootingPlans";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(planIds);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processQueryNoRelationShootingPlans(_response);
        });
    }

    protected processQueryNoRelationShootingPlans(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    queryNoRelationShootingPlansWithTime(st: Date | undefined, et: Date | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/STCS/QueryNoRelationShootingPlansWithTime?";
        if (st === null)
            throw new Error("The parameter 'st' cannot be null.");
        else if (st !== undefined)
            url_ += "st=" + encodeURIComponent(st ? "" + st.toISOString() : "") + "&";
        if (et === null)
            throw new Error("The parameter 'et' cannot be null.");
        else if (et !== undefined)
            url_ += "et=" + encodeURIComponent(et ? "" + et.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processQueryNoRelationShootingPlansWithTime(_response);
        });
    }

    protected processQueryNoRelationShootingPlansWithTime(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    queryShootingPlan(planId: number | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/STCS/QueryShootingPlan?";
        if (planId === null)
            throw new Error("The parameter 'planId' cannot be null.");
        else if (planId !== undefined)
            url_ += "planId=" + encodeURIComponent("" + planId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processQueryShootingPlan(_response);
        });
    }

    protected processQueryShootingPlan(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    queryShootingPicPath(planId: number | undefined, roundIdx: number | undefined, targetIdx: number | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/STCS/QueryShootingPicPath?";
        if (planId === null)
            throw new Error("The parameter 'planId' cannot be null.");
        else if (planId !== undefined)
            url_ += "planId=" + encodeURIComponent("" + planId) + "&";
        if (roundIdx === null)
            throw new Error("The parameter 'roundIdx' cannot be null.");
        else if (roundIdx !== undefined)
            url_ += "roundIdx=" + encodeURIComponent("" + roundIdx) + "&";
        if (targetIdx === null)
            throw new Error("The parameter 'targetIdx' cannot be null.");
        else if (targetIdx !== undefined)
            url_ += "targetIdx=" + encodeURIComponent("" + targetIdx) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processQueryShootingPicPath(_response);
        });
    }

    protected processQueryShootingPicPath(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    addOrUpdateShootingPlan(plan: ShootingPlan): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/STCS/AddOrUpdateShootingPlan";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(plan);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processAddOrUpdateShootingPlan(_response);
        });
    }

    protected processAddOrUpdateShootingPlan(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    delShootingPlan(planId: number | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/STCS/DelShootingPlan?";
        if (planId === null)
            throw new Error("The parameter 'planId' cannot be null.");
        else if (planId !== undefined)
            url_ += "planId=" + encodeURIComponent("" + planId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDelShootingPlan(_response);
        });
    }

    protected processDelShootingPlan(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    addOrUpdateShootingPerson(sp: ShootingPerson): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/STCS/AddOrUpdateShootingPerson";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(sp);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processAddOrUpdateShootingPerson(_response);
        });
    }

    protected processAddOrUpdateShootingPerson(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    delShootingPerson(spId: number | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/STCS/DelShootingPerson?";
        if (spId === null)
            throw new Error("The parameter 'spId' cannot be null.");
        else if (spId !== undefined)
            url_ += "spId=" + encodeURIComponent("" + spId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDelShootingPerson(_response);
        });
    }

    protected processDelShootingPerson(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    addOrUpdateShootingTarget(st: ShootingTarget): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/STCS/AddOrUpdateShootingTarget";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(st);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processAddOrUpdateShootingTarget(_response);
        });
    }

    protected processAddOrUpdateShootingTarget(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    delShootingTarget(stId: number | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/STCS/DelShootingTarget?";
        if (stId === null)
            throw new Error("The parameter 'stId' cannot be null.");
        else if (stId !== undefined)
            url_ += "stId=" + encodeURIComponent("" + stId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDelShootingTarget(_response);
        });
    }

    protected processDelShootingTarget(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    addOrUpdateShootingTargetAction(staction: ShootingTargetAction): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/STCS/AddOrUpdateShootingTargetAction";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(staction);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processAddOrUpdateShootingTargetAction(_response);
        });
    }

    protected processAddOrUpdateShootingTargetAction(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    delShootingTargetAction(stactionId: number | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/STCS/DelShootingTargetAction?";
        if (stactionId === null)
            throw new Error("The parameter 'stactionId' cannot be null.");
        else if (stactionId !== undefined)
            url_ += "stactionId=" + encodeURIComponent("" + stactionId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDelShootingTargetAction(_response);
        });
    }

    protected processDelShootingTargetAction(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    addOrUpdateShootingResultRecord(staction: ShootingResultRecord): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/STCS/AddOrUpdateShootingResultRecord";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(staction);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processAddOrUpdateShootingResultRecord(_response);
        });
    }

    protected processAddOrUpdateShootingResultRecord(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    queryTargetModels(): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/STCS/QueryTargetModels";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processQueryTargetModels(_response);
        });
    }

    protected processQueryTargetModels(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    addOrUpdateTargetModel(targetmodel: TargetModel): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/STCS/AddOrUpdateTargetModel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(targetmodel);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processAddOrUpdateTargetModel(_response);
        });
    }

    protected processAddOrUpdateTargetModel(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    delTargetModel(modelId: number | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/STCS/DelTargetModel?";
        if (modelId === null)
            throw new Error("The parameter 'modelId' cannot be null.");
        else if (modelId !== undefined)
            url_ += "modelId=" + encodeURIComponent("" + modelId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDelTargetModel(_response);
        });
    }

    protected processDelTargetModel(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    queryTargetSubjects(): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/STCS/QueryTargetSubjects";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processQueryTargetSubjects(_response);
        });
    }

    protected processQueryTargetSubjects(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    addOrUpdateTargetSubject(subject: TargetSubject): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/STCS/AddOrUpdateTargetSubject";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(subject);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processAddOrUpdateTargetSubject(_response);
        });
    }

    protected processAddOrUpdateTargetSubject(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    delTargetSubject(id: number | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/STCS/DelTargetSubject?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDelTargetSubject(_response);
        });
    }

    protected processDelTargetSubject(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    sendVoice2Target(targetVoice: TargetVoiceParam): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/STCS/SendVoice2Target";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(targetVoice);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSendVoice2Target(_response);
        });
    }

    protected processSendVoice2Target(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    sendMsg2Target(msg: string | null | undefined, sendInfo: SendParam): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/STCS/SendMsg2Target?";
        if (msg !== undefined && msg !== null)
            url_ += "msg=" + encodeURIComponent("" + msg) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(sendInfo);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSendMsg2Target(_response);
        });
    }

    protected processSendMsg2Target(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    focusAllTpzTarget(): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/STCS/FocusAllTpzTarget";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processFocusAllTpzTarget(_response);
        });
    }

    protected processFocusAllTpzTarget(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    notifyRecvShootingCountEvent(info: ShootingCountInfo): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/STCS/NotifyRecvShootingCountEvent";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(info);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processNotifyRecvShootingCountEvent(_response);
        });
    }

    protected processNotifyRecvShootingCountEvent(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    startPracticePlan(planId: number | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/STCS/StartPracticePlan?";
        if (planId === null)
            throw new Error("The parameter 'planId' cannot be null.");
        else if (planId !== undefined)
            url_ += "planId=" + encodeURIComponent("" + planId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processStartPracticePlan(_response);
        });
    }

    protected processStartPracticePlan(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    prepareRound(planId: number | undefined, roundIdx: number | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/STCS/PrepareRound?";
        if (planId === null)
            throw new Error("The parameter 'planId' cannot be null.");
        else if (planId !== undefined)
            url_ += "planId=" + encodeURIComponent("" + planId) + "&";
        if (roundIdx === null)
            throw new Error("The parameter 'roundIdx' cannot be null.");
        else if (roundIdx !== undefined)
            url_ += "roundIdx=" + encodeURIComponent("" + roundIdx) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processPrepareRound(_response);
        });
    }

    protected processPrepareRound(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    forcePrepareRound(planId: number | undefined, roundIdx: number | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/STCS/ForcePrepareRound?";
        if (planId === null)
            throw new Error("The parameter 'planId' cannot be null.");
        else if (planId !== undefined)
            url_ += "planId=" + encodeURIComponent("" + planId) + "&";
        if (roundIdx === null)
            throw new Error("The parameter 'roundIdx' cannot be null.");
        else if (roundIdx !== undefined)
            url_ += "roundIdx=" + encodeURIComponent("" + roundIdx) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processForcePrepareRound(_response);
        });
    }

    protected processForcePrepareRound(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    stopPracticePlan(planId: number | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/STCS/StopPracticePlan?";
        if (planId === null)
            throw new Error("The parameter 'planId' cannot be null.");
        else if (planId !== undefined)
            url_ += "planId=" + encodeURIComponent("" + planId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processStopPracticePlan(_response);
        });
    }

    protected processStopPracticePlan(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    sendTargetCtrlCommand(info: TargetCtrlParam): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/STCS/SendTargetCtrlCommand";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(info);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSendTargetCtrlCommand(_response);
        });
    }

    protected processSendTargetCtrlCommand(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    sendTargetIdxCtrlCommand(info: TargetIdxCtrlParam): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/STCS/SendTargetIdxCtrlCommand";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(info);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSendTargetIdxCtrlCommand(_response);
        });
    }

    protected processSendTargetIdxCtrlCommand(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    getRecordData(): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/STCS/GetRecordData";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetRecordData(_response);
        });
    }

    protected processGetRecordData(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    resetUserPassword(userID: number | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/STCS/ResetUserPassword?";
        if (userID === null)
            throw new Error("The parameter 'userID' cannot be null.");
        else if (userID !== undefined)
            url_ += "userID=" + encodeURIComponent("" + userID) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processResetUserPassword(_response);
        });
    }

    protected processResetUserPassword(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    uploadFileDataUploadFileData(fileName: string | null | undefined, buffer: string): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/STCS/UploadFileDataUploadFileData?";
        if (fileName !== undefined && fileName !== null)
            url_ += "fileName=" + encodeURIComponent("" + fileName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(buffer);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUploadFileDataUploadFileData(_response);
        });
    }

    protected processUploadFileDataUploadFileData(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    login(param: LoginParam): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/STCS/Login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(param);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processLogin(_response);
        });
    }

    protected processLogin(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    targetLogin(targetIdx: number | undefined, pw: string | null | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/STCS/TargetLogin?";
        if (targetIdx === null)
            throw new Error("The parameter 'targetIdx' cannot be null.");
        else if (targetIdx !== undefined)
            url_ += "targetIdx=" + encodeURIComponent("" + targetIdx) + "&";
        if (pw !== undefined && pw !== null)
            url_ += "pw=" + encodeURIComponent("" + pw) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processTargetLogin(_response);
        });
    }

    protected processTargetLogin(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    logout(): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/STCS/Logout";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processLogout(_response);
        });
    }

    protected processLogout(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    clientLoadResFinished(): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/STCS/ClientLoadResFinished";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processClientLoadResFinished(_response);
        });
    }

    protected processClientLoadResFinished(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    stopServerSystem(): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/STCS/StopServerSystem";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processStopServerSystem(_response);
        });
    }

    protected processStopServerSystem(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    synchronizePersonInfo(devPerson: DevPersonParam): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/STCS/SynchronizePersonInfo";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(devPerson);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSynchronizePersonInfo(_response);
        });
    }

    protected processSynchronizePersonInfo(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    syncDeviceCallNum(devs: number[]): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/STCS/SyncDeviceCallNum";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(devs);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSyncDeviceCallNum(_response);
        });
    }

    protected processSyncDeviceCallNum(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    syncMidisPreviewInfo(devID: number | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/STCS/SyncMidisPreviewInfo?";
        if (devID === null)
            throw new Error("The parameter 'devID' cannot be null.");
        else if (devID !== undefined)
            url_ += "devID=" + encodeURIComponent("" + devID) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSyncMidisPreviewInfo(_response);
        });
    }

    protected processSyncMidisPreviewInfo(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    syncAudioDataToDevice(devAudios: DevAudioParam): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/STCS/SyncAudioDataToDevice";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(devAudios);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSyncAudioDataToDevice(_response);
        });
    }

    protected processSyncAudioDataToDevice(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    sendPtzCmd(cmdInfo: PtzCmdParam): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/STCS/SendPtzCmd";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(cmdInfo);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSendPtzCmd(_response);
        });
    }

    protected processSendPtzCmd(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    getStreamUrl(param: PlayParam): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/STCS/GetStreamUrl";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(param);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetStreamUrl(_response);
        });
    }

    protected processGetStreamUrl(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    startVideo(param: PlayParam): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/STCS/StartVideo";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(param);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processStartVideo(_response);
        });
    }

    protected processStartVideo(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    stopVideo(playHandle: number | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/STCS/StopVideo?";
        if (playHandle === null)
            throw new Error("The parameter 'playHandle' cannot be null.");
        else if (playHandle !== undefined)
            url_ += "playHandle=" + encodeURIComponent("" + playHandle) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processStopVideo(_response);
        });
    }

    protected processStopVideo(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    confirmAlarmEvent(eventID: number | undefined, isMis: boolean | undefined, misInfo: string | null | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/STCS/ConfirmAlarmEvent?";
        if (eventID === null)
            throw new Error("The parameter 'eventID' cannot be null.");
        else if (eventID !== undefined)
            url_ += "eventID=" + encodeURIComponent("" + eventID) + "&";
        if (isMis === null)
            throw new Error("The parameter 'isMis' cannot be null.");
        else if (isMis !== undefined)
            url_ += "isMis=" + encodeURIComponent("" + isMis) + "&";
        if (misInfo !== undefined && misInfo !== null)
            url_ += "misInfo=" + encodeURIComponent("" + misInfo) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processConfirmAlarmEvent(_response);
        });
    }

    protected processConfirmAlarmEvent(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    finishAlarmEvent(eventID: number | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/STCS/FinishAlarmEvent?";
        if (eventID === null)
            throw new Error("The parameter 'eventID' cannot be null.");
        else if (eventID !== undefined)
            url_ += "eventID=" + encodeURIComponent("" + eventID) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processFinishAlarmEvent(_response);
        });
    }

    protected processFinishAlarmEvent(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    restoreAlarm(): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/STCS/RestoreAlarm";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processRestoreAlarm(_response);
        });
    }

    protected processRestoreAlarm(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    testManualStartAlarm(dev: number | undefined, type: DevType | undefined, chanIdx: number | undefined, alarmType: string | null | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/STCS/TestManualStartAlarm?";
        if (dev === null)
            throw new Error("The parameter 'dev' cannot be null.");
        else if (dev !== undefined)
            url_ += "dev=" + encodeURIComponent("" + dev) + "&";
        if (type === null)
            throw new Error("The parameter 'type' cannot be null.");
        else if (type !== undefined)
            url_ += "type=" + encodeURIComponent("" + type) + "&";
        if (chanIdx === null)
            throw new Error("The parameter 'chanIdx' cannot be null.");
        else if (chanIdx !== undefined)
            url_ += "chanIdx=" + encodeURIComponent("" + chanIdx) + "&";
        if (alarmType !== undefined && alarmType !== null)
            url_ += "alarmType=" + encodeURIComponent("" + alarmType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processTestManualStartAlarm(_response);
        });
    }

    protected processTestManualStartAlarm(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    rebootDevice(devID: number | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/STCS/RebootDevice?";
        if (devID === null)
            throw new Error("The parameter 'devID' cannot be null.");
        else if (devID !== undefined)
            url_ += "devID=" + encodeURIComponent("" + devID) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processRebootDevice(_response);
        });
    }

    protected processRebootDevice(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    rebootDevices(devs: number[]): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/STCS/RebootDevices";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(devs);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processRebootDevices(_response);
        });
    }

    protected processRebootDevices(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    sendAlarmKeyConfig2Sentry(devIds: number[]): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/STCS/SendAlarmKeyConfig2Sentry";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(devIds);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSendAlarmKeyConfig2Sentry(_response);
        });
    }

    protected processSendAlarmKeyConfig2Sentry(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    sendAlarmEvent2Targets(eventId: number | undefined, devs: number[]): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/STCS/SendAlarmEvent2Targets?";
        if (eventId === null)
            throw new Error("The parameter 'eventId' cannot be null.");
        else if (eventId !== undefined)
            url_ += "eventId=" + encodeURIComponent("" + eventId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(devs);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSendAlarmEvent2Targets(_response);
        });
    }

    protected processSendAlarmEvent2Targets(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    sendProNotifyInfo(info: string | null | undefined, devs: number[]): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/STCS/SendProNotifyInfo?";
        if (info !== undefined && info !== null)
            url_ += "info=" + encodeURIComponent("" + info) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(devs);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSendProNotifyInfo(_response);
        });
    }

    protected processSendProNotifyInfo(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    reportPreSchemeHandledRecord(info: PreSchemeHandledParam): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/STCS/ReportPreSchemeHandledRecord";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(info);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processReportPreSchemeHandledRecord(_response);
        });
    }

    protected processReportPreSchemeHandledRecord(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    sendMessage(message: MessageParam): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/STCS/SendMessage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(message);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSendMessage(_response);
        });
    }

    protected processSendMessage(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    gunBulletCtrlDeviceAuthPwdPass(): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/STCS/GunBulletCtrlDeviceAuthPwdPass";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGunBulletCtrlDeviceAuthPwdPass(_response);
        });
    }

    protected processGunBulletCtrlDeviceAuthPwdPass(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    queryCurrentTime(): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/STCS/QueryCurrentTime";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processQueryCurrentTime(_response);
        });
    }

    protected processQueryCurrentTime(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    queryServerInfo(): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/STCS/QueryServerInfo";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processQueryServerInfo(_response);
        });
    }

    protected processQueryServerInfo(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    queryDBInfo(): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/STCS/QueryDBInfo";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processQueryDBInfo(_response);
        });
    }

    protected processQueryDBInfo(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    queryLoginSessions(): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/STCS/QueryLoginSessions";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processQueryLoginSessions(_response);
        });
    }

    protected processQueryLoginSessions(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    querySessions(): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/STCS/QuerySessions";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processQuerySessions(_response);
        });
    }

    protected processQuerySessions(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    addOrUpdateUserInfo(userInfo: UserInfo): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/STCS/AddOrUpdateUserInfo";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(userInfo);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processAddOrUpdateUserInfo(_response);
        });
    }

    protected processAddOrUpdateUserInfo(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    delUserInfo(id: number | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/STCS/DelUserInfo?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDelUserInfo(_response);
        });
    }

    protected processDelUserInfo(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    queryUserInfo(userType: SessionType | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/STCS/QueryUserInfo?";
        if (userType === null)
            throw new Error("The parameter 'userType' cannot be null.");
        else if (userType !== undefined)
            url_ += "userType=" + encodeURIComponent("" + userType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processQueryUserInfo(_response);
        });
    }

    protected processQueryUserInfo(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    querySingleUserInfo(itemID: number | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/STCS/QuerySingleUserInfo?";
        if (itemID === null)
            throw new Error("The parameter 'itemID' cannot be null.");
        else if (itemID !== undefined)
            url_ += "itemID=" + encodeURIComponent("" + itemID) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processQuerySingleUserInfo(_response);
        });
    }

    protected processQuerySingleUserInfo(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    addOrUpdateUserGroupInfo(groupInfo: UserGroupInfo): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/STCS/AddOrUpdateUserGroupInfo";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(groupInfo);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processAddOrUpdateUserGroupInfo(_response);
        });
    }

    protected processAddOrUpdateUserGroupInfo(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    delUserGroupInfo(id: number | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/STCS/DelUserGroupInfo?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDelUserGroupInfo(_response);
        });
    }

    protected processDelUserGroupInfo(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    queryUserGroupInfo(): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/STCS/QueryUserGroupInfo";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processQueryUserGroupInfo(_response);
        });
    }

    protected processQueryUserGroupInfo(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    confUserGroupPurview(id: number | undefined, items: UserGroupPurview[]): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/STCS/ConfUserGroupPurview?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(items);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processConfUserGroupPurview(_response);
        });
    }

    protected processConfUserGroupPurview(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    queryUserGroupPurview(groupId: number | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/STCS/QueryUserGroupPurview?";
        if (groupId === null)
            throw new Error("The parameter 'groupId' cannot be null.");
        else if (groupId !== undefined)
            url_ += "groupId=" + encodeURIComponent("" + groupId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processQueryUserGroupPurview(_response);
        });
    }

    protected processQueryUserGroupPurview(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    confSysConfigInfo(confInfoList: SystemKeyInfo[]): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/STCS/ConfSysConfigInfo";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(confInfoList);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processConfSysConfigInfo(_response);
        });
    }

    protected processConfSysConfigInfo(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    querySysConfigInfos(groupName: string | null | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/STCS/QuerySysConfigInfos?";
        if (groupName !== undefined && groupName !== null)
            url_ += "groupName=" + encodeURIComponent("" + groupName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processQuerySysConfigInfos(_response);
        });
    }

    protected processQuerySysConfigInfos(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    querySingleSysConfigInfo(paramKey: string | null | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/STCS/QuerySingleSysConfigInfo?";
        if (paramKey !== undefined && paramKey !== null)
            url_ += "paramKey=" + encodeURIComponent("" + paramKey) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processQuerySingleSysConfigInfo(_response);
        });
    }

    protected processQuerySingleSysConfigInfo(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    querySysGroupInfos(groupName: string | null | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/STCS/QuerySysGroupInfos?";
        if (groupName !== undefined && groupName !== null)
            url_ += "groupName=" + encodeURIComponent("" + groupName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processQuerySysGroupInfos(_response);
        });
    }

    protected processQuerySysGroupInfos(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    addOrUpdateSysGroupInfo(groupinfo: SystemResourceInfo): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/STCS/AddOrUpdateSysGroupInfo";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(groupinfo);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processAddOrUpdateSysGroupInfo(_response);
        });
    }

    protected processAddOrUpdateSysGroupInfo(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    delSysGroupItem(itemId: number | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/STCS/DelSysGroupItem?";
        if (itemId === null)
            throw new Error("The parameter 'itemId' cannot be null.");
        else if (itemId !== undefined)
            url_ += "itemId=" + encodeURIComponent("" + itemId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDelSysGroupItem(_response);
        });
    }

    protected processDelSysGroupItem(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    confSysGroupInfos(configGroup: string | null | undefined, groupinfo: SystemResourceInfo[]): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/STCS/ConfSysGroupInfos?";
        if (configGroup !== undefined && configGroup !== null)
            url_ += "configGroup=" + encodeURIComponent("" + configGroup) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(groupinfo);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processConfSysGroupInfos(_response);
        });
    }

    protected processConfSysGroupInfos(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    addOrUpdateOpLog(iRt: number | undefined, log: string | null | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/STCS/AddOrUpdateOpLog?";
        if (iRt === null)
            throw new Error("The parameter 'iRt' cannot be null.");
        else if (iRt !== undefined)
            url_ += "iRt=" + encodeURIComponent("" + iRt) + "&";
        if (log !== undefined && log !== null)
            url_ += "log=" + encodeURIComponent("" + log) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processAddOrUpdateOpLog(_response);
        });
    }

    protected processAddOrUpdateOpLog(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    getFileData(path: string | null | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/STCS/GetFileData?";
        if (path !== undefined && path !== null)
            url_ += "path=" + encodeURIComponent("" + path) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetFileData(_response);
        });
    }

    protected processGetFileData(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    queryPersonInfos(): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/STCS/QueryPersonInfos";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processQueryPersonInfos(_response);
        });
    }

    protected processQueryPersonInfos(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    querySinglePersonInfos(id: number | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/STCS/QuerySinglePersonInfos?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processQuerySinglePersonInfos(_response);
        });
    }

    protected processQuerySinglePersonInfos(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    addOrUpdatePersonInfo(info: PersonInfo): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/STCS/AddOrUpdatePersonInfo";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(info);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processAddOrUpdatePersonInfo(_response);
        });
    }

    protected processAddOrUpdatePersonInfo(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    delPersonInfo(id: number | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/STCS/DelPersonInfo?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDelPersonInfo(_response);
        });
    }

    protected processDelPersonInfo(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    queryPersonResources(id: number | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/STCS/QueryPersonResources?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processQueryPersonResources(_response);
        });
    }

    protected processQueryPersonResources(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    delPersonResource(resId: number | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/STCS/DelPersonResource?";
        if (resId === null)
            throw new Error("The parameter 'resId' cannot be null.");
        else if (resId !== undefined)
            url_ += "resId=" + encodeURIComponent("" + resId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDelPersonResource(_response);
        });
    }

    protected processDelPersonResource(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    addPersonResources(info: PersonResData): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/STCS/AddPersonResources";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(info);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processAddPersonResources(_response);
        });
    }

    protected processAddPersonResources(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    addOrUpdateVideoGroupInfo(groupInfo: VideoGroupInfo): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/STCS/AddOrUpdateVideoGroupInfo";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(groupInfo);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processAddOrUpdateVideoGroupInfo(_response);
        });
    }

    protected processAddOrUpdateVideoGroupInfo(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    delVideoGroupInfo(groupID: number | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/STCS/DelVideoGroupInfo?";
        if (groupID === null)
            throw new Error("The parameter 'groupID' cannot be null.");
        else if (groupID !== undefined)
            url_ += "groupID=" + encodeURIComponent("" + groupID) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDelVideoGroupInfo(_response);
        });
    }

    protected processDelVideoGroupInfo(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    queryVideoGroupInfo(): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/STCS/QueryVideoGroupInfo";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processQueryVideoGroupInfo(_response);
        });
    }

    protected processQueryVideoGroupInfo(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    addOrUpdateMediaScene(sceneInfo: VideoSceneInfo): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/STCS/AddOrUpdateMediaScene";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(sceneInfo);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processAddOrUpdateMediaScene(_response);
        });
    }

    protected processAddOrUpdateMediaScene(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    delMediaScene(id: number | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/STCS/DelMediaScene?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDelMediaScene(_response);
        });
    }

    protected processDelMediaScene(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    queryMediaScene(): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/STCS/QueryMediaScene";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processQueryMediaScene(_response);
        });
    }

    protected processQueryMediaScene(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    queryVideoLinkInfos(): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/STCS/QueryVideoLinkInfos";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processQueryVideoLinkInfos(_response);
        });
    }

    protected processQueryVideoLinkInfos(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    addOrUpdateMapInfo(mapInfo: MapParam): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/STCS/AddOrUpdateMapInfo";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(mapInfo);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processAddOrUpdateMapInfo(_response);
        });
    }

    protected processAddOrUpdateMapInfo(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    delMapInfo(id: number | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/STCS/DelMapInfo?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDelMapInfo(_response);
        });
    }

    protected processDelMapInfo(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    queryMapInfo(): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/STCS/QueryMapInfo";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processQueryMapInfo(_response);
        });
    }

    protected processQueryMapInfo(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    addOrUpdateMapRelConfigInfo(confInfo: MapRelKeyInfo): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/STCS/AddOrUpdateMapRelConfigInfo";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(confInfo);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processAddOrUpdateMapRelConfigInfo(_response);
        });
    }

    protected processAddOrUpdateMapRelConfigInfo(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    delMapRelConfigInfo(id: number | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/STCS/DelMapRelConfigInfo?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDelMapRelConfigInfo(_response);
        });
    }

    protected processDelMapRelConfigInfo(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    queryMapRelConfigInfo(id: number): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/STCS/QueryMapRelConfigInfo/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processQueryMapRelConfigInfo(_response);
        });
    }

    protected processQueryMapRelConfigInfo(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    addOrUpdateAreaInfo(areaInfo: MapRelAreaInfo): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/STCS/AddOrUpdateAreaInfo";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(areaInfo);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processAddOrUpdateAreaInfo(_response);
        });
    }

    protected processAddOrUpdateAreaInfo(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    delAreaInfo(itemID: number | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/STCS/DelAreaInfo?";
        if (itemID === null)
            throw new Error("The parameter 'itemID' cannot be null.");
        else if (itemID !== undefined)
            url_ += "itemID=" + encodeURIComponent("" + itemID) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDelAreaInfo(_response);
        });
    }

    protected processDelAreaInfo(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    queryAreaInfo(mapID: number | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/STCS/QueryAreaInfo?";
        if (mapID === null)
            throw new Error("The parameter 'mapID' cannot be null.");
        else if (mapID !== undefined)
            url_ += "mapID=" + encodeURIComponent("" + mapID) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processQueryAreaInfo(_response);
        });
    }

    protected processQueryAreaInfo(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    addOrUpdateMonitorPointInfo(monitorInfo: MonitorInfo): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/STCS/AddOrUpdateMonitorPointInfo";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(monitorInfo);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processAddOrUpdateMonitorPointInfo(_response);
        });
    }

    protected processAddOrUpdateMonitorPointInfo(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    delMonitorPointInfo(monitorID: number | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/STCS/DelMonitorPointInfo?";
        if (monitorID === null)
            throw new Error("The parameter 'monitorID' cannot be null.");
        else if (monitorID !== undefined)
            url_ += "monitorID=" + encodeURIComponent("" + monitorID) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDelMonitorPointInfo(_response);
        });
    }

    protected processDelMonitorPointInfo(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    queryMonitorPointInfo(): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/STCS/QueryMonitorPointInfo";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processQueryMonitorPointInfo(_response);
        });
    }

    protected processQueryMonitorPointInfo(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    confMonitorRelSrcInfo(monitorId: number | undefined, relInfos: MonitorRelResourceInfo[]): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/STCS/ConfMonitorRelSrcInfo?";
        if (monitorId === null)
            throw new Error("The parameter 'monitorId' cannot be null.");
        else if (monitorId !== undefined)
            url_ += "monitorId=" + encodeURIComponent("" + monitorId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(relInfos);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processConfMonitorRelSrcInfo(_response);
        });
    }

    protected processConfMonitorRelSrcInfo(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    queryMonitorRelSrcInfo(monitorId: number | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/STCS/QueryMonitorRelSrcInfo?";
        if (monitorId === null)
            throw new Error("The parameter 'monitorId' cannot be null.");
        else if (monitorId !== undefined)
            url_ += "monitorId=" + encodeURIComponent("" + monitorId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processQueryMonitorRelSrcInfo(_response);
        });
    }

    protected processQueryMonitorRelSrcInfo(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    addOrUpdateMapRelMonitorInfo(relInfos: MapRelMonitorInfo): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/STCS/AddOrUpdateMapRelMonitorInfo";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(relInfos);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processAddOrUpdateMapRelMonitorInfo(_response);
        });
    }

    protected processAddOrUpdateMapRelMonitorInfo(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    delMapRelMonitorInfo(mapId: number | undefined, monitorId: number | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/STCS/DelMapRelMonitorInfo?";
        if (mapId === null)
            throw new Error("The parameter 'mapId' cannot be null.");
        else if (mapId !== undefined)
            url_ += "mapId=" + encodeURIComponent("" + mapId) + "&";
        if (monitorId === null)
            throw new Error("The parameter 'monitorId' cannot be null.");
        else if (monitorId !== undefined)
            url_ += "monitorId=" + encodeURIComponent("" + monitorId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDelMapRelMonitorInfo(_response);
        });
    }

    protected processDelMapRelMonitorInfo(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    queryMapRelMonitorInfo(mapId: number | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/STCS/QueryMapRelMonitorInfo?";
        if (mapId === null)
            throw new Error("The parameter 'mapId' cannot be null.");
        else if (mapId !== undefined)
            url_ += "mapId=" + encodeURIComponent("" + mapId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processQueryMapRelMonitorInfo(_response);
        });
    }

    protected processQueryMapRelMonitorInfo(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    confMapRelVideoSourceInfo(mapID: number | undefined, relInfos: MapRelResourceInfo[]): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/STCS/ConfMapRelVideoSourceInfo?";
        if (mapID === null)
            throw new Error("The parameter 'mapID' cannot be null.");
        else if (mapID !== undefined)
            url_ += "mapID=" + encodeURIComponent("" + mapID) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(relInfos);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processConfMapRelVideoSourceInfo(_response);
        });
    }

    protected processConfMapRelVideoSourceInfo(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    queryMapRelVideoSourceInfo(mapID: number | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/STCS/QueryMapRelVideoSourceInfo?";
        if (mapID === null)
            throw new Error("The parameter 'mapID' cannot be null.");
        else if (mapID !== undefined)
            url_ += "mapID=" + encodeURIComponent("" + mapID) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processQueryMapRelVideoSourceInfo(_response);
        });
    }

    protected processQueryMapRelVideoSourceInfo(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }
}

export class MapImportantDataInfo implements IMapImportantDataInfo {
    id?: number;
    title?: string | undefined;
    keyType?: ImportantDataType;
    content?: string | undefined;
    param?: string | undefined;
    occurTime?: Date;
    modifyTime?: Date;

    constructor(data?: IMapImportantDataInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.keyType = _data["keyType"];
            this.content = _data["content"];
            this.param = _data["param"];
            this.occurTime = _data["occurTime"] ? new Date(_data["occurTime"].toString()) : <any>undefined;
            this.modifyTime = _data["modifyTime"] ? new Date(_data["modifyTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): MapImportantDataInfo {
        data = typeof data === 'object' ? data : {};
        let result = new MapImportantDataInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["keyType"] = this.keyType;
        data["content"] = this.content;
        data["param"] = this.param;
        data["occurTime"] = this.occurTime ? this.occurTime.toISOString() : <any>undefined;
        data["modifyTime"] = this.modifyTime ? this.modifyTime.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IMapImportantDataInfo {
    id?: number;
    title?: string | undefined;
    keyType?: ImportantDataType;
    content?: string | undefined;
    param?: string | undefined;
    occurTime?: Date;
    modifyTime?: Date;
}

export enum ImportantDataType {
    UserDef = 0,
    Duty = 1,
    Weather = 2,
}

export class AlarmTypeInfo implements IAlarmTypeInfo {
    id?: number;
    name?: string | undefined;
    isDelete?: boolean;
    defType?: DefType;
    alarmGroup?: AlarmGroup;
    filePath?: string | undefined;
    occurTime?: Date;
    modifyTime?: Date;

    constructor(data?: IAlarmTypeInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.isDelete = _data["isDelete"];
            this.defType = _data["defType"];
            this.alarmGroup = _data["alarmGroup"];
            this.filePath = _data["filePath"];
            this.occurTime = _data["occurTime"] ? new Date(_data["occurTime"].toString()) : <any>undefined;
            this.modifyTime = _data["modifyTime"] ? new Date(_data["modifyTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): AlarmTypeInfo {
        data = typeof data === 'object' ? data : {};
        let result = new AlarmTypeInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["isDelete"] = this.isDelete;
        data["defType"] = this.defType;
        data["alarmGroup"] = this.alarmGroup;
        data["filePath"] = this.filePath;
        data["occurTime"] = this.occurTime ? this.occurTime.toISOString() : <any>undefined;
        data["modifyTime"] = this.modifyTime ? this.modifyTime.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IAlarmTypeInfo {
    id?: number;
    name?: string | undefined;
    isDelete?: boolean;
    defType?: DefType;
    alarmGroup?: AlarmGroup;
    filePath?: string | undefined;
    occurTime?: Date;
    modifyTime?: Date;
}

export enum DefType {
    PreDef = 0,
    UserDef = 1,
}

export enum AlarmGroup {
    Normal = 0,
    Key = 1,
    AudioWarning = 2,
    GunWarning = 3,
}

export class AlarmSchemeInfo implements IAlarmSchemeInfo {
    id?: number;
    name?: string | undefined;
    isDelete?: boolean;
    occurTime?: Date;
    modifyTime?: Date;
    desc?: string | undefined;
    schemeItemList?: AlarmSchemeItem[] | undefined;

    constructor(data?: IAlarmSchemeInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.isDelete = _data["isDelete"];
            this.occurTime = _data["occurTime"] ? new Date(_data["occurTime"].toString()) : <any>undefined;
            this.modifyTime = _data["modifyTime"] ? new Date(_data["modifyTime"].toString()) : <any>undefined;
            this.desc = _data["desc"];
            if (Array.isArray(_data["schemeItemList"])) {
                this.schemeItemList = [] as any;
                for (let item of _data["schemeItemList"])
                    this.schemeItemList!.push(AlarmSchemeItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AlarmSchemeInfo {
        data = typeof data === 'object' ? data : {};
        let result = new AlarmSchemeInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["isDelete"] = this.isDelete;
        data["occurTime"] = this.occurTime ? this.occurTime.toISOString() : <any>undefined;
        data["modifyTime"] = this.modifyTime ? this.modifyTime.toISOString() : <any>undefined;
        data["desc"] = this.desc;
        if (Array.isArray(this.schemeItemList)) {
            data["schemeItemList"] = [];
            for (let item of this.schemeItemList)
                data["schemeItemList"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IAlarmSchemeInfo {
    id?: number;
    name?: string | undefined;
    isDelete?: boolean;
    occurTime?: Date;
    modifyTime?: Date;
    desc?: string | undefined;
    schemeItemList?: AlarmSchemeItem[] | undefined;
}

export class AlarmSchemeItem implements IAlarmSchemeItem {
    id?: number;
    alarmSchemeId?: number;
    isDelete?: boolean;
    content?: string | undefined;
    path?: string | undefined;
    occurTime?: Date;
    modifyTime?: Date;

    constructor(data?: IAlarmSchemeItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.alarmSchemeId = _data["alarmSchemeId"];
            this.isDelete = _data["isDelete"];
            this.content = _data["content"];
            this.path = _data["path"];
            this.occurTime = _data["occurTime"] ? new Date(_data["occurTime"].toString()) : <any>undefined;
            this.modifyTime = _data["modifyTime"] ? new Date(_data["modifyTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): AlarmSchemeItem {
        data = typeof data === 'object' ? data : {};
        let result = new AlarmSchemeItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["alarmSchemeId"] = this.alarmSchemeId;
        data["isDelete"] = this.isDelete;
        data["content"] = this.content;
        data["path"] = this.path;
        data["occurTime"] = this.occurTime ? this.occurTime.toISOString() : <any>undefined;
        data["modifyTime"] = this.modifyTime ? this.modifyTime.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IAlarmSchemeItem {
    id?: number;
    alarmSchemeId?: number;
    isDelete?: boolean;
    content?: string | undefined;
    path?: string | undefined;
    occurTime?: Date;
    modifyTime?: Date;
}

export class AlarmSourceRelTypeInfo implements IAlarmSourceRelTypeInfo {
    id?: number;
    sourceId?: number;
    alarmTypeId?: number;
    alarmCls?: string | undefined;
    alarmTypeName?: string | undefined;
    isEnable?: boolean;
    isNeedConfirm?: boolean;
    invalidTime?: number;
    occurTime?: Date;
    alarmType?: AlarmTypeInfo | undefined;
    resource?: ResourceInfo | undefined;

    constructor(data?: IAlarmSourceRelTypeInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.sourceId = _data["sourceId"];
            this.alarmTypeId = _data["alarmTypeId"];
            this.alarmCls = _data["alarmCls"];
            this.alarmTypeName = _data["alarmTypeName"];
            this.isEnable = _data["isEnable"];
            this.isNeedConfirm = _data["isNeedConfirm"];
            this.invalidTime = _data["invalidTime"];
            this.occurTime = _data["occurTime"] ? new Date(_data["occurTime"].toString()) : <any>undefined;
            this.alarmType = _data["alarmType"] ? AlarmTypeInfo.fromJS(_data["alarmType"]) : <any>undefined;
            this.resource = _data["resource"] ? ResourceInfo.fromJS(_data["resource"]) : <any>undefined;
        }
    }

    static fromJS(data: any): AlarmSourceRelTypeInfo {
        data = typeof data === 'object' ? data : {};
        let result = new AlarmSourceRelTypeInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["sourceId"] = this.sourceId;
        data["alarmTypeId"] = this.alarmTypeId;
        data["alarmCls"] = this.alarmCls;
        data["alarmTypeName"] = this.alarmTypeName;
        data["isEnable"] = this.isEnable;
        data["isNeedConfirm"] = this.isNeedConfirm;
        data["invalidTime"] = this.invalidTime;
        data["occurTime"] = this.occurTime ? this.occurTime.toISOString() : <any>undefined;
        data["alarmType"] = this.alarmType ? this.alarmType.toJSON() : <any>undefined;
        data["resource"] = this.resource ? this.resource.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IAlarmSourceRelTypeInfo {
    id?: number;
    sourceId?: number;
    alarmTypeId?: number;
    alarmCls?: string | undefined;
    alarmTypeName?: string | undefined;
    isEnable?: boolean;
    isNeedConfirm?: boolean;
    invalidTime?: number;
    occurTime?: Date;
    alarmType?: AlarmTypeInfo | undefined;
    resource?: ResourceInfo | undefined;
}

export class ResourceInfo implements IResourceInfo {
    id?: number;
    name?: string | undefined;
    isDelete?: boolean;
    isEnable?: boolean;
    isAlarmSource?: boolean;
    devType?: DevType;
    srcId?: number;
    index?: number;
    tag?: string | undefined;
    occurTime?: Date;
    modifyTime?: Date;
    resKeyInfoList?: ResourceRelKeyInfo[] | undefined;

    constructor(data?: IResourceInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.isDelete = _data["isDelete"];
            this.isEnable = _data["isEnable"];
            this.isAlarmSource = _data["isAlarmSource"];
            this.devType = _data["devType"];
            this.srcId = _data["srcId"];
            this.index = _data["index"];
            this.tag = _data["tag"];
            this.occurTime = _data["occurTime"] ? new Date(_data["occurTime"].toString()) : <any>undefined;
            this.modifyTime = _data["modifyTime"] ? new Date(_data["modifyTime"].toString()) : <any>undefined;
            if (Array.isArray(_data["resKeyInfoList"])) {
                this.resKeyInfoList = [] as any;
                for (let item of _data["resKeyInfoList"])
                    this.resKeyInfoList!.push(ResourceRelKeyInfo.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ResourceInfo {
        data = typeof data === 'object' ? data : {};
        let result = new ResourceInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["isDelete"] = this.isDelete;
        data["isEnable"] = this.isEnable;
        data["isAlarmSource"] = this.isAlarmSource;
        data["devType"] = this.devType;
        data["srcId"] = this.srcId;
        data["index"] = this.index;
        data["tag"] = this.tag;
        data["occurTime"] = this.occurTime ? this.occurTime.toISOString() : <any>undefined;
        data["modifyTime"] = this.modifyTime ? this.modifyTime.toISOString() : <any>undefined;
        if (Array.isArray(this.resKeyInfoList)) {
            data["resKeyInfoList"] = [];
            for (let item of this.resKeyInfoList)
                data["resKeyInfoList"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IResourceInfo {
    id?: number;
    name?: string | undefined;
    isDelete?: boolean;
    isEnable?: boolean;
    isAlarmSource?: boolean;
    devType?: DevType;
    srcId?: number;
    index?: number;
    tag?: string | undefined;
    occurTime?: Date;
    modifyTime?: Date;
    resKeyInfoList?: ResourceRelKeyInfo[] | undefined;
}

export enum DevType {
    Unknown = 0,
    AlarmLight = 7,
    Camera = 14,
    CameraGroup = 15,
    GateCtrlTerm = 19,
    MtsServer = 20,
    Radar = 21,
    FaceRecoServer = 23,
    ElectronicGuard = 25,
    MAS = 27,
    AlarmAnalyseServer = 32,
    ShakingOpticalDev = 33,
    MidisServer = 35,
    ShakeAlarm = 38,
    SubServerSystem = 42,
    NtpServer = 43,
    LocationServer = 44,
    WeatherStation = 45,
    TargetDev = 46,
    WifiGyro = 47,
    BulletCtrler = 48,
}

export class ResourceRelKeyInfo implements IResourceRelKeyInfo {
    id?: number;
    srcId?: number;
    configKey?: string | undefined;
    configValue?: string | undefined;
    occurTime?: Date;
    modifyTime?: Date;
    resourceInfo?: ResourceInfo | undefined;

    constructor(data?: IResourceRelKeyInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.srcId = _data["srcId"];
            this.configKey = _data["configKey"];
            this.configValue = _data["configValue"];
            this.occurTime = _data["occurTime"] ? new Date(_data["occurTime"].toString()) : <any>undefined;
            this.modifyTime = _data["modifyTime"] ? new Date(_data["modifyTime"].toString()) : <any>undefined;
            this.resourceInfo = _data["resourceInfo"] ? ResourceInfo.fromJS(_data["resourceInfo"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ResourceRelKeyInfo {
        data = typeof data === 'object' ? data : {};
        let result = new ResourceRelKeyInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["srcId"] = this.srcId;
        data["configKey"] = this.configKey;
        data["configValue"] = this.configValue;
        data["occurTime"] = this.occurTime ? this.occurTime.toISOString() : <any>undefined;
        data["modifyTime"] = this.modifyTime ? this.modifyTime.toISOString() : <any>undefined;
        data["resourceInfo"] = this.resourceInfo ? this.resourceInfo.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IResourceRelKeyInfo {
    id?: number;
    srcId?: number;
    configKey?: string | undefined;
    configValue?: string | undefined;
    occurTime?: Date;
    modifyTime?: Date;
    resourceInfo?: ResourceInfo | undefined;
}

export class AlarmLinkInfo implements IAlarmLinkInfo {
    id?: number;
    alarmSourceID?: number;
    relTypeId?: number;
    linkModel?: AlarmLinkMode;
    linkSrcId?: number;
    linkAction?: LinkActionType;
    linkContent?: string | undefined;
    occurTime?: Date;

    constructor(data?: IAlarmLinkInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.alarmSourceID = _data["alarmSourceID"];
            this.relTypeId = _data["relTypeId"];
            this.linkModel = _data["linkModel"];
            this.linkSrcId = _data["linkSrcId"];
            this.linkAction = _data["linkAction"];
            this.linkContent = _data["linkContent"];
            this.occurTime = _data["occurTime"] ? new Date(_data["occurTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): AlarmLinkInfo {
        data = typeof data === 'object' ? data : {};
        let result = new AlarmLinkInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["alarmSourceID"] = this.alarmSourceID;
        data["relTypeId"] = this.relTypeId;
        data["linkModel"] = this.linkModel;
        data["linkSrcId"] = this.linkSrcId;
        data["linkAction"] = this.linkAction;
        data["linkContent"] = this.linkContent;
        data["occurTime"] = this.occurTime ? this.occurTime.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IAlarmLinkInfo {
    id?: number;
    alarmSourceID?: number;
    relTypeId?: number;
    linkModel?: AlarmLinkMode;
    linkSrcId?: number;
    linkAction?: LinkActionType;
    linkContent?: string | undefined;
    occurTime?: Date;
}

export enum AlarmLinkMode {
    All = 0,
    BeforeConfirm = 1,
    AfterConfirm = 2,
}

export enum LinkActionType {
    PlayVideo = 0,
    Snap = 1,
    Storage = 2,
    SpeechNotify = 3,
    TextNotify = 4,
    SwitchOutput = 5,
    TurnOnLight = 6,
    EditPreview = 7,
    MidisPreview = 8,
}

export class DeviceInfo implements IDeviceInfo {
    id?: number;
    isDelete?: boolean;
    name?: string | undefined;
    isEnable?: boolean;
    devType?: DevType;
    devSubType?: DeviceSubType;
    vendor?: DevVendor;
    capability?: number;
    outCapability?: number;
    transType?: TransType;
    ip?: string | undefined;
    port?: number;
    userName?: string | undefined;
    password?: string | undefined;
    tag?: string | undefined;
    modifyTime?: Date;
    occurTime?: Date;
    deviceResourceList?: DevRelResourceInfo[] | undefined;
    devKeyInfoList?: DevRelKeyInfo[] | undefined;

    constructor(data?: IDeviceInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.isDelete = _data["isDelete"];
            this.name = _data["name"];
            this.isEnable = _data["isEnable"];
            this.devType = _data["devType"];
            this.devSubType = _data["devSubType"];
            this.vendor = _data["vendor"];
            this.capability = _data["capability"];
            this.outCapability = _data["outCapability"];
            this.transType = _data["transType"];
            this.ip = _data["ip"];
            this.port = _data["port"];
            this.userName = _data["userName"];
            this.password = _data["password"];
            this.tag = _data["tag"];
            this.modifyTime = _data["modifyTime"] ? new Date(_data["modifyTime"].toString()) : <any>undefined;
            this.occurTime = _data["occurTime"] ? new Date(_data["occurTime"].toString()) : <any>undefined;
            if (Array.isArray(_data["deviceResourceList"])) {
                this.deviceResourceList = [] as any;
                for (let item of _data["deviceResourceList"])
                    this.deviceResourceList!.push(DevRelResourceInfo.fromJS(item));
            }
            if (Array.isArray(_data["devKeyInfoList"])) {
                this.devKeyInfoList = [] as any;
                for (let item of _data["devKeyInfoList"])
                    this.devKeyInfoList!.push(DevRelKeyInfo.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DeviceInfo {
        data = typeof data === 'object' ? data : {};
        let result = new DeviceInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["isDelete"] = this.isDelete;
        data["name"] = this.name;
        data["isEnable"] = this.isEnable;
        data["devType"] = this.devType;
        data["devSubType"] = this.devSubType;
        data["vendor"] = this.vendor;
        data["capability"] = this.capability;
        data["outCapability"] = this.outCapability;
        data["transType"] = this.transType;
        data["ip"] = this.ip;
        data["port"] = this.port;
        data["userName"] = this.userName;
        data["password"] = this.password;
        data["tag"] = this.tag;
        data["modifyTime"] = this.modifyTime ? this.modifyTime.toISOString() : <any>undefined;
        data["occurTime"] = this.occurTime ? this.occurTime.toISOString() : <any>undefined;
        if (Array.isArray(this.deviceResourceList)) {
            data["deviceResourceList"] = [];
            for (let item of this.deviceResourceList)
                data["deviceResourceList"].push(item.toJSON());
        }
        if (Array.isArray(this.devKeyInfoList)) {
            data["devKeyInfoList"] = [];
            for (let item of this.devKeyInfoList)
                data["devKeyInfoList"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IDeviceInfo {
    id?: number;
    isDelete?: boolean;
    name?: string | undefined;
    isEnable?: boolean;
    devType?: DevType;
    devSubType?: DeviceSubType;
    vendor?: DevVendor;
    capability?: number;
    outCapability?: number;
    transType?: TransType;
    ip?: string | undefined;
    port?: number;
    userName?: string | undefined;
    password?: string | undefined;
    tag?: string | undefined;
    modifyTime?: Date;
    occurTime?: Date;
    deviceResourceList?: DevRelResourceInfo[] | undefined;
    devKeyInfoList?: DevRelKeyInfo[] | undefined;
}

export enum DeviceSubType {
    Unknown = 0,
    AlarmLight_SixColor = 200,
    AlarmLight_FiveColor = 201,
    AlarmLight_FourColor = 202,
    Camera_GunCamera = 900,
    Camera_BallCamera = 901,
    Camera_EagleCamera = 902,
    Camera_Nvr = 925,
    Camera_Group = 950,
    ElectronicGuard_Base = 1000,
    ElectronicGuard_Sub = 1001,
    GateCtrlTerm_Finger = 1002,
    GateCtrlTerm_Face = 1003,
    FaceRecoServer_DH = 1300,
    FaceRecoServer_HIK = 1301,
    MtsServer_100F = 1500,
    MtsServer_100M = 1501,
    MtsServer_110M = 1502,
    MtsServer_120M = 1503,
    AG_AlarmGateway = 1600,
    Radar_RsvRadar = 1700,
    Radar_38Radar = 1701,
    Radar_ProtocolRadar = 1702,
    Radar_HikPARadar = 1703,
    MAS_Base = 1900,
    MAS_Extent = 1901,
    AlarmAnalyseServer = 2400,
    ShakingOpticalDev = 2500,
    DutyDetectionDev = 2600,
    MidisServer_DW = 2700,
    MidisServer_CK = 2701,
    ExDevServerSystem = 3400,
    DevServerSystem = 3401,
    MediaServerSystem = 3402,
    TargetPracticeServerSystem = 3403,
    NtpServer = 3500,
    LocationServer_ZXW = 3600,
    WeatherStation = 3700,
    TargetDev_Target_Precision = 3800,
    TargetDev_Target_Hit = 3801,
    TargetDev_Target_ConductivePrecision = 3802,
    TargetDev_Mobile = 3850,
    BulletCtrler = 4000,
    BulletCtrlerDev = 4001,
}

export enum DevVendor {
    Vendor_Unkonw = 0,
    Vendor_TOPZEN = 1,
    Vendor_HIK = 2,
    Vendor_DAHUA = 3,
    Vendor_BOCONG = 4,
    Vendor_HIS = 5,
    Vendor_UNV = 6,
    Vendor_Tiandy = 7,
    Vendor_RY = 8,
    Vendor_ZENO = 9,
    Vendor_RSV = 10,
    Vendor_CETC38 = 11,
    Vendor_ZKT = 12,
    Vendor_ZXW = 13,
    Vendor_Wr = 14,
    Vendor_Br = 15,
    Vendor_Wr3 = 16,
    Vendor_UnisYue = 17,
    Vendor_IteaQ = 18,
    Vendor_Sxw = 19,
    Vendor_Kuanyao = 20,
    Vendor_JG = 21,
}

export enum TransType {
    Protocol = 0,
    SERIAL = 1,
    USB = 2,
    SubServer = 3,
}

export class DevRelResourceInfo implements IDevRelResourceInfo {
    id?: number;
    resourcID?: number;
    resType?: ResType;
    devID?: number;
    occurTime?: Date;
    deviceInfo?: DeviceInfo | undefined;

    constructor(data?: IDevRelResourceInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.resourcID = _data["resourcID"];
            this.resType = _data["resType"];
            this.devID = _data["devID"];
            this.occurTime = _data["occurTime"] ? new Date(_data["occurTime"].toString()) : <any>undefined;
            this.deviceInfo = _data["deviceInfo"] ? DeviceInfo.fromJS(_data["deviceInfo"]) : <any>undefined;
        }
    }

    static fromJS(data: any): DevRelResourceInfo {
        data = typeof data === 'object' ? data : {};
        let result = new DevRelResourceInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["resourcID"] = this.resourcID;
        data["resType"] = this.resType;
        data["devID"] = this.devID;
        data["occurTime"] = this.occurTime ? this.occurTime.toISOString() : <any>undefined;
        data["deviceInfo"] = this.deviceInfo ? this.deviceInfo.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IDevRelResourceInfo {
    id?: number;
    resourcID?: number;
    resType?: ResType;
    devID?: number;
    occurTime?: Date;
    deviceInfo?: DeviceInfo | undefined;
}

export enum ResType {
    Dev = 0,
    Resource = 1,
    AlarmSource = 2,
    VideoGroup = 3,
    Unknow = -1,
}

export class DevRelKeyInfo implements IDevRelKeyInfo {
    id?: number;
    srcId?: number;
    configKey?: string | undefined;
    configValue?: string | undefined;
    occurTime?: Date;
    modifyTime?: Date;
    deviceInfo?: DeviceInfo | undefined;

    constructor(data?: IDevRelKeyInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.srcId = _data["srcId"];
            this.configKey = _data["configKey"];
            this.configValue = _data["configValue"];
            this.occurTime = _data["occurTime"] ? new Date(_data["occurTime"].toString()) : <any>undefined;
            this.modifyTime = _data["modifyTime"] ? new Date(_data["modifyTime"].toString()) : <any>undefined;
            this.deviceInfo = _data["deviceInfo"] ? DeviceInfo.fromJS(_data["deviceInfo"]) : <any>undefined;
        }
    }

    static fromJS(data: any): DevRelKeyInfo {
        data = typeof data === 'object' ? data : {};
        let result = new DevRelKeyInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["srcId"] = this.srcId;
        data["configKey"] = this.configKey;
        data["configValue"] = this.configValue;
        data["occurTime"] = this.occurTime ? this.occurTime.toISOString() : <any>undefined;
        data["modifyTime"] = this.modifyTime ? this.modifyTime.toISOString() : <any>undefined;
        data["deviceInfo"] = this.deviceInfo ? this.deviceInfo.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IDevRelKeyInfo {
    id?: number;
    srcId?: number;
    configKey?: string | undefined;
    configValue?: string | undefined;
    occurTime?: Date;
    modifyTime?: Date;
    deviceInfo?: DeviceInfo | undefined;
}

export class FileData implements IFileData {
    fileName?: string | undefined;
    fileType?: FileType;
    data?: string | undefined;
    desc?: string | undefined;

    constructor(data?: IFileData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fileName = _data["fileName"];
            this.fileType = _data["fileType"];
            this.data = _data["data"];
            this.desc = _data["desc"];
        }
    }

    static fromJS(data: any): FileData {
        data = typeof data === 'object' ? data : {};
        let result = new FileData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fileName"] = this.fileName;
        data["fileType"] = this.fileType;
        data["data"] = this.data;
        data["desc"] = this.desc;
        return data; 
    }
}

export interface IFileData {
    fileName?: string | undefined;
    fileType?: FileType;
    data?: string | undefined;
    desc?: string | undefined;
}

export enum FileType {
    PersonPic = 0,
    PersonAuthData = 1,
    Map = 2,
    Snap = 3,
    Storage = 4,
    Audio = 5,
    Target = 6,
    TargetPicture = 7,
    Other = 8,
}

export class ShootingGunTrackRecord implements IShootingGunTrackRecord {
    id?: number;
    planId?: number;
    personId?: number;
    round?: number;
    xAcceleratedSpeed?: number;
    xAngleSpeed?: number;
    xAngle?: number;
    yAcceleratedSpeed?: number;
    yAngleSpeed?: number;
    yAngle?: number;
    zAcceleratedSpeed?: number;
    zAngleSpeed?: number;
    zAngle?: number;
    occurTime?: Date;

    constructor(data?: IShootingGunTrackRecord) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.planId = _data["planId"];
            this.personId = _data["personId"];
            this.round = _data["round"];
            this.xAcceleratedSpeed = _data["xAcceleratedSpeed"];
            this.xAngleSpeed = _data["xAngleSpeed"];
            this.xAngle = _data["xAngle"];
            this.yAcceleratedSpeed = _data["yAcceleratedSpeed"];
            this.yAngleSpeed = _data["yAngleSpeed"];
            this.yAngle = _data["yAngle"];
            this.zAcceleratedSpeed = _data["zAcceleratedSpeed"];
            this.zAngleSpeed = _data["zAngleSpeed"];
            this.zAngle = _data["zAngle"];
            this.occurTime = _data["occurTime"] ? new Date(_data["occurTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ShootingGunTrackRecord {
        data = typeof data === 'object' ? data : {};
        let result = new ShootingGunTrackRecord();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["planId"] = this.planId;
        data["personId"] = this.personId;
        data["round"] = this.round;
        data["xAcceleratedSpeed"] = this.xAcceleratedSpeed;
        data["xAngleSpeed"] = this.xAngleSpeed;
        data["xAngle"] = this.xAngle;
        data["yAcceleratedSpeed"] = this.yAcceleratedSpeed;
        data["yAngleSpeed"] = this.yAngleSpeed;
        data["yAngle"] = this.yAngle;
        data["zAcceleratedSpeed"] = this.zAcceleratedSpeed;
        data["zAngleSpeed"] = this.zAngleSpeed;
        data["zAngle"] = this.zAngle;
        data["occurTime"] = this.occurTime ? this.occurTime.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IShootingGunTrackRecord {
    id?: number;
    planId?: number;
    personId?: number;
    round?: number;
    xAcceleratedSpeed?: number;
    xAngleSpeed?: number;
    xAngle?: number;
    yAcceleratedSpeed?: number;
    yAngleSpeed?: number;
    yAngle?: number;
    zAcceleratedSpeed?: number;
    zAngleSpeed?: number;
    zAngle?: number;
    occurTime?: Date;
}

export class ShootingPlan implements IShootingPlan {
    id?: number;
    name?: string | undefined;
    subjectId?: number;
    bulletNumber?: number;
    targetCount?: number;
    roundCount?: number;
    planState?: PlanState;
    targetAction?: TargetActionType;
    carAction?: TargetActionType;
    executionRound?: number;
    startTime?: Date;
    endTime?: Date;
    canUsePersons?: string | undefined;
    desc?: string | undefined;
    occurTime?: Date;
    modifyTime?: Date;
    targetSubject?: TargetSubject | undefined;
    relShootingPersonList?: ShootingPerson[] | undefined;
    relShootingTargetList?: ShootingTarget[] | undefined;
    relShootingActionList?: ShootingTargetAction[] | undefined;

    constructor(data?: IShootingPlan) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.subjectId = _data["subjectId"];
            this.bulletNumber = _data["bulletNumber"];
            this.targetCount = _data["targetCount"];
            this.roundCount = _data["roundCount"];
            this.planState = _data["planState"];
            this.targetAction = _data["targetAction"];
            this.carAction = _data["carAction"];
            this.executionRound = _data["executionRound"];
            this.startTime = _data["startTime"] ? new Date(_data["startTime"].toString()) : <any>undefined;
            this.endTime = _data["endTime"] ? new Date(_data["endTime"].toString()) : <any>undefined;
            this.canUsePersons = _data["canUsePersons"];
            this.desc = _data["desc"];
            this.occurTime = _data["occurTime"] ? new Date(_data["occurTime"].toString()) : <any>undefined;
            this.modifyTime = _data["modifyTime"] ? new Date(_data["modifyTime"].toString()) : <any>undefined;
            this.targetSubject = _data["targetSubject"] ? TargetSubject.fromJS(_data["targetSubject"]) : <any>undefined;
            if (Array.isArray(_data["relShootingPersonList"])) {
                this.relShootingPersonList = [] as any;
                for (let item of _data["relShootingPersonList"])
                    this.relShootingPersonList!.push(ShootingPerson.fromJS(item));
            }
            if (Array.isArray(_data["relShootingTargetList"])) {
                this.relShootingTargetList = [] as any;
                for (let item of _data["relShootingTargetList"])
                    this.relShootingTargetList!.push(ShootingTarget.fromJS(item));
            }
            if (Array.isArray(_data["relShootingActionList"])) {
                this.relShootingActionList = [] as any;
                for (let item of _data["relShootingActionList"])
                    this.relShootingActionList!.push(ShootingTargetAction.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ShootingPlan {
        data = typeof data === 'object' ? data : {};
        let result = new ShootingPlan();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["subjectId"] = this.subjectId;
        data["bulletNumber"] = this.bulletNumber;
        data["targetCount"] = this.targetCount;
        data["roundCount"] = this.roundCount;
        data["planState"] = this.planState;
        data["targetAction"] = this.targetAction;
        data["carAction"] = this.carAction;
        data["executionRound"] = this.executionRound;
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toISOString() : <any>undefined;
        data["canUsePersons"] = this.canUsePersons;
        data["desc"] = this.desc;
        data["occurTime"] = this.occurTime ? this.occurTime.toISOString() : <any>undefined;
        data["modifyTime"] = this.modifyTime ? this.modifyTime.toISOString() : <any>undefined;
        data["targetSubject"] = this.targetSubject ? this.targetSubject.toJSON() : <any>undefined;
        if (Array.isArray(this.relShootingPersonList)) {
            data["relShootingPersonList"] = [];
            for (let item of this.relShootingPersonList)
                data["relShootingPersonList"].push(item.toJSON());
        }
        if (Array.isArray(this.relShootingTargetList)) {
            data["relShootingTargetList"] = [];
            for (let item of this.relShootingTargetList)
                data["relShootingTargetList"].push(item.toJSON());
        }
        if (Array.isArray(this.relShootingActionList)) {
            data["relShootingActionList"] = [];
            for (let item of this.relShootingActionList)
                data["relShootingActionList"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IShootingPlan {
    id?: number;
    name?: string | undefined;
    subjectId?: number;
    bulletNumber?: number;
    targetCount?: number;
    roundCount?: number;
    planState?: PlanState;
    targetAction?: TargetActionType;
    carAction?: TargetActionType;
    executionRound?: number;
    startTime?: Date;
    endTime?: Date;
    canUsePersons?: string | undefined;
    desc?: string | undefined;
    occurTime?: Date;
    modifyTime?: Date;
    targetSubject?: TargetSubject | undefined;
    relShootingPersonList?: ShootingPerson[] | undefined;
    relShootingTargetList?: ShootingTarget[] | undefined;
    relShootingActionList?: ShootingTargetAction[] | undefined;
}

export enum PlanState {
    Create = 0,
    Doing = 1,
    Finish = 2,
}

export enum TargetActionType {
    None = 0,
    DownAction = 1,
    StopAction = 2,
}

export class TargetSubject implements ITargetSubject {
    id?: number;
    name?: string | undefined;
    subjectType?: string | undefined;
    targetModel?: string | undefined;
    bulletCount?: number;
    text?: string | undefined;
    occurTime?: Date;
    modifyTime?: Date;

    constructor(data?: ITargetSubject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.subjectType = _data["subjectType"];
            this.targetModel = _data["targetModel"];
            this.bulletCount = _data["bulletCount"];
            this.text = _data["text"];
            this.occurTime = _data["occurTime"] ? new Date(_data["occurTime"].toString()) : <any>undefined;
            this.modifyTime = _data["modifyTime"] ? new Date(_data["modifyTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): TargetSubject {
        data = typeof data === 'object' ? data : {};
        let result = new TargetSubject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["subjectType"] = this.subjectType;
        data["targetModel"] = this.targetModel;
        data["bulletCount"] = this.bulletCount;
        data["text"] = this.text;
        data["occurTime"] = this.occurTime ? this.occurTime.toISOString() : <any>undefined;
        data["modifyTime"] = this.modifyTime ? this.modifyTime.toISOString() : <any>undefined;
        return data; 
    }
}

export interface ITargetSubject {
    id?: number;
    name?: string | undefined;
    subjectType?: string | undefined;
    targetModel?: string | undefined;
    bulletCount?: number;
    text?: string | undefined;
    occurTime?: Date;
    modifyTime?: Date;
}

export class ShootingPerson implements IShootingPerson {
    id?: number;
    planId?: number;
    round!: number;
    targetIdx!: number;
    personId?: number;
    desc?: string | undefined;
    occurTime?: Date;
    modifyTime?: Date;
    shootingPlan?: ShootingPlan | undefined;

    constructor(data?: IShootingPerson) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.planId = _data["planId"];
            this.round = _data["round"];
            this.targetIdx = _data["targetIdx"];
            this.personId = _data["personId"];
            this.desc = _data["desc"];
            this.occurTime = _data["occurTime"] ? new Date(_data["occurTime"].toString()) : <any>undefined;
            this.modifyTime = _data["modifyTime"] ? new Date(_data["modifyTime"].toString()) : <any>undefined;
            this.shootingPlan = _data["shootingPlan"] ? ShootingPlan.fromJS(_data["shootingPlan"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ShootingPerson {
        data = typeof data === 'object' ? data : {};
        let result = new ShootingPerson();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["planId"] = this.planId;
        data["round"] = this.round;
        data["targetIdx"] = this.targetIdx;
        data["personId"] = this.personId;
        data["desc"] = this.desc;
        data["occurTime"] = this.occurTime ? this.occurTime.toISOString() : <any>undefined;
        data["modifyTime"] = this.modifyTime ? this.modifyTime.toISOString() : <any>undefined;
        data["shootingPlan"] = this.shootingPlan ? this.shootingPlan.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IShootingPerson {
    id?: number;
    planId?: number;
    round: number;
    targetIdx: number;
    personId?: number;
    desc?: string | undefined;
    occurTime?: Date;
    modifyTime?: Date;
    shootingPlan?: ShootingPlan | undefined;
}

export class ShootingTarget implements IShootingTarget {
    id?: number;
    planId?: number;
    targetIdx?: number;
    targetModelId?: number;
    occurTime?: Date;
    modifyTime?: Date;
    shootingPlan?: ShootingPlan | undefined;

    constructor(data?: IShootingTarget) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.planId = _data["planId"];
            this.targetIdx = _data["targetIdx"];
            this.targetModelId = _data["targetModelId"];
            this.occurTime = _data["occurTime"] ? new Date(_data["occurTime"].toString()) : <any>undefined;
            this.modifyTime = _data["modifyTime"] ? new Date(_data["modifyTime"].toString()) : <any>undefined;
            this.shootingPlan = _data["shootingPlan"] ? ShootingPlan.fromJS(_data["shootingPlan"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ShootingTarget {
        data = typeof data === 'object' ? data : {};
        let result = new ShootingTarget();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["planId"] = this.planId;
        data["targetIdx"] = this.targetIdx;
        data["targetModelId"] = this.targetModelId;
        data["occurTime"] = this.occurTime ? this.occurTime.toISOString() : <any>undefined;
        data["modifyTime"] = this.modifyTime ? this.modifyTime.toISOString() : <any>undefined;
        data["shootingPlan"] = this.shootingPlan ? this.shootingPlan.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IShootingTarget {
    id?: number;
    planId?: number;
    targetIdx?: number;
    targetModelId?: number;
    occurTime?: Date;
    modifyTime?: Date;
    shootingPlan?: ShootingPlan | undefined;
}

export class ShootingTargetAction implements IShootingTargetAction {
    id?: number;
    planId?: number;
    targetIdx?: number;
    shootingAction?: ShootingAction;
    param?: string | undefined;
    pointTime?: number;
    occurTime?: Date;
    modifyTime?: Date;
    shootingPlan?: ShootingPlan | undefined;

    constructor(data?: IShootingTargetAction) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.planId = _data["planId"];
            this.targetIdx = _data["targetIdx"];
            this.shootingAction = _data["shootingAction"];
            this.param = _data["param"];
            this.pointTime = _data["pointTime"];
            this.occurTime = _data["occurTime"] ? new Date(_data["occurTime"].toString()) : <any>undefined;
            this.modifyTime = _data["modifyTime"] ? new Date(_data["modifyTime"].toString()) : <any>undefined;
            this.shootingPlan = _data["shootingPlan"] ? ShootingPlan.fromJS(_data["shootingPlan"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ShootingTargetAction {
        data = typeof data === 'object' ? data : {};
        let result = new ShootingTargetAction();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["planId"] = this.planId;
        data["targetIdx"] = this.targetIdx;
        data["shootingAction"] = this.shootingAction;
        data["param"] = this.param;
        data["pointTime"] = this.pointTime;
        data["occurTime"] = this.occurTime ? this.occurTime.toISOString() : <any>undefined;
        data["modifyTime"] = this.modifyTime ? this.modifyTime.toISOString() : <any>undefined;
        data["shootingPlan"] = this.shootingPlan ? this.shootingPlan.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IShootingTargetAction {
    id?: number;
    planId?: number;
    targetIdx?: number;
    shootingAction?: ShootingAction;
    param?: string | undefined;
    pointTime?: number;
    occurTime?: Date;
    modifyTime?: Date;
    shootingPlan?: ShootingPlan | undefined;
}

export enum ShootingAction {
    PositiveTarget = 1,
    ContraryTarget = 2,
    Speed1ForwardStart = 50,
    Speed2ForwardStart = 51,
    Speed3ForwardStart = 52,
    Speed4ForwardStart = 53,
    BackwardStart = 54,
    Stop = 55,
    LightLevel0 = 100,
    LightLevel1 = 101,
    LightLevel2 = 102,
    LightLevel3 = 103,
    LightLevel4 = 104,
    LightLevel5 = 105,
}

export class ShootingResultRecord implements IShootingResultRecord {
    id?: number;
    planId?: number;
    targetIdx?: number;
    targetType?: TargetType;
    targetModelId?: number;
    roundIdx?: number;
    personId?: number;
    shootingGesture?: string | undefined;
    shootingIdx?: number;
    isHit?: boolean;
    code?: number;
    direction?: TargetLoopPlace;
    x?: number;
    y?: number;
    isRecvPic?: boolean;
    realPicX?: number;
    realPicY?: number;
    occurTime?: Date;

    constructor(data?: IShootingResultRecord) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.planId = _data["planId"];
            this.targetIdx = _data["targetIdx"];
            this.targetType = _data["targetType"];
            this.targetModelId = _data["targetModelId"];
            this.roundIdx = _data["roundIdx"];
            this.personId = _data["personId"];
            this.shootingGesture = _data["shootingGesture"];
            this.shootingIdx = _data["shootingIdx"];
            this.isHit = _data["isHit"];
            this.code = _data["code"];
            this.direction = _data["direction"];
            this.x = _data["x"];
            this.y = _data["y"];
            this.isRecvPic = _data["isRecvPic"];
            this.realPicX = _data["realPicX"];
            this.realPicY = _data["realPicY"];
            this.occurTime = _data["occurTime"] ? new Date(_data["occurTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ShootingResultRecord {
        data = typeof data === 'object' ? data : {};
        let result = new ShootingResultRecord();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["planId"] = this.planId;
        data["targetIdx"] = this.targetIdx;
        data["targetType"] = this.targetType;
        data["targetModelId"] = this.targetModelId;
        data["roundIdx"] = this.roundIdx;
        data["personId"] = this.personId;
        data["shootingGesture"] = this.shootingGesture;
        data["shootingIdx"] = this.shootingIdx;
        data["isHit"] = this.isHit;
        data["code"] = this.code;
        data["direction"] = this.direction;
        data["x"] = this.x;
        data["y"] = this.y;
        data["isRecvPic"] = this.isRecvPic;
        data["realPicX"] = this.realPicX;
        data["realPicY"] = this.realPicY;
        data["occurTime"] = this.occurTime ? this.occurTime.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IShootingResultRecord {
    id?: number;
    planId?: number;
    targetIdx?: number;
    targetType?: TargetType;
    targetModelId?: number;
    roundIdx?: number;
    personId?: number;
    shootingGesture?: string | undefined;
    shootingIdx?: number;
    isHit?: boolean;
    code?: number;
    direction?: TargetLoopPlace;
    x?: number;
    y?: number;
    isRecvPic?: boolean;
    realPicX?: number;
    realPicY?: number;
    occurTime?: Date;
}

export enum TargetType {
    Precision = 0,
    Area = 1,
    Hit = 2,
}

export enum TargetLoopPlace {
    CentrePlace = 0,
    Up = 1,
    RightUp = 2,
    Right = 3,
    RightDown = 4,
    Down = 5,
    LeftDown = 6,
    Left = 7,
    LeftUp = 8,
    Error = -1,
}

export class TargetModel implements ITargetModel {
    id?: number;
    name?: string | undefined;
    picPath?: string | undefined;
    actionTag?: string | undefined;
    desc?: string | undefined;
    occurTime?: Date;
    modifyTime?: Date;
    picData?: string | undefined;

    constructor(data?: ITargetModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.picPath = _data["picPath"];
            this.actionTag = _data["actionTag"];
            this.desc = _data["desc"];
            this.occurTime = _data["occurTime"] ? new Date(_data["occurTime"].toString()) : <any>undefined;
            this.modifyTime = _data["modifyTime"] ? new Date(_data["modifyTime"].toString()) : <any>undefined;
            this.picData = _data["picData"];
        }
    }

    static fromJS(data: any): TargetModel {
        data = typeof data === 'object' ? data : {};
        let result = new TargetModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["picPath"] = this.picPath;
        data["actionTag"] = this.actionTag;
        data["desc"] = this.desc;
        data["occurTime"] = this.occurTime ? this.occurTime.toISOString() : <any>undefined;
        data["modifyTime"] = this.modifyTime ? this.modifyTime.toISOString() : <any>undefined;
        data["picData"] = this.picData;
        return data; 
    }
}

export interface ITargetModel {
    id?: number;
    name?: string | undefined;
    picPath?: string | undefined;
    actionTag?: string | undefined;
    desc?: string | undefined;
    occurTime?: Date;
    modifyTime?: Date;
    picData?: string | undefined;
}

export class TargetVoiceParam implements ITargetVoiceParam {
    targetIdxs?: number[] | undefined;
    voiceData?: string | undefined;

    constructor(data?: ITargetVoiceParam) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["targetIdxs"])) {
                this.targetIdxs = [] as any;
                for (let item of _data["targetIdxs"])
                    this.targetIdxs!.push(item);
            }
            this.voiceData = _data["voiceData"];
        }
    }

    static fromJS(data: any): TargetVoiceParam {
        data = typeof data === 'object' ? data : {};
        let result = new TargetVoiceParam();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.targetIdxs)) {
            data["targetIdxs"] = [];
            for (let item of this.targetIdxs)
                data["targetIdxs"].push(item);
        }
        data["voiceData"] = this.voiceData;
        return data; 
    }
}

export interface ITargetVoiceParam {
    targetIdxs?: number[] | undefined;
    voiceData?: string | undefined;
}

export class SendParam implements ISendParam {
    session?: SessionInfo | undefined;
    targetIdxs?: number[] | undefined;

    constructor(data?: ISendParam) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.session = _data["session"] ? SessionInfo.fromJS(_data["session"]) : <any>undefined;
            if (Array.isArray(_data["targetIdxs"])) {
                this.targetIdxs = [] as any;
                for (let item of _data["targetIdxs"])
                    this.targetIdxs!.push(item);
            }
        }
    }

    static fromJS(data: any): SendParam {
        data = typeof data === 'object' ? data : {};
        let result = new SendParam();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["session"] = this.session ? this.session.toJSON() : <any>undefined;
        if (Array.isArray(this.targetIdxs)) {
            data["targetIdxs"] = [];
            for (let item of this.targetIdxs)
                data["targetIdxs"].push(item);
        }
        return data; 
    }
}

export interface ISendParam {
    session?: SessionInfo | undefined;
    targetIdxs?: number[] | undefined;
}

export class SessionInfo implements ISessionInfo {
    sessionId?: string | undefined;
    sessionType?: SessionType;
    ip?: string | undefined;
    port?: number;
    userId?: number;
    userName?: string | undefined;
    isLogin?: boolean;
    isLoadResFinished?: boolean;
    occurTime?: Date;
    loginTime?: Date;
    logoutTime?: Date;

    constructor(data?: ISessionInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sessionId = _data["sessionId"];
            this.sessionType = _data["sessionType"];
            this.ip = _data["ip"];
            this.port = _data["port"];
            this.userId = _data["userId"];
            this.userName = _data["userName"];
            this.isLogin = _data["isLogin"];
            this.isLoadResFinished = _data["isLoadResFinished"];
            this.occurTime = _data["occurTime"] ? new Date(_data["occurTime"].toString()) : <any>undefined;
            this.loginTime = _data["loginTime"] ? new Date(_data["loginTime"].toString()) : <any>undefined;
            this.logoutTime = _data["logoutTime"] ? new Date(_data["logoutTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): SessionInfo {
        data = typeof data === 'object' ? data : {};
        let result = new SessionInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sessionId"] = this.sessionId;
        data["sessionType"] = this.sessionType;
        data["ip"] = this.ip;
        data["port"] = this.port;
        data["userId"] = this.userId;
        data["userName"] = this.userName;
        data["isLogin"] = this.isLogin;
        data["isLoadResFinished"] = this.isLoadResFinished;
        data["occurTime"] = this.occurTime ? this.occurTime.toISOString() : <any>undefined;
        data["loginTime"] = this.loginTime ? this.loginTime.toISOString() : <any>undefined;
        data["logoutTime"] = this.logoutTime ? this.logoutTime.toISOString() : <any>undefined;
        return data; 
    }
}

export interface ISessionInfo {
    sessionId?: string | undefined;
    sessionType?: SessionType;
    ip?: string | undefined;
    port?: number;
    userId?: number;
    userName?: string | undefined;
    isLogin?: boolean;
    isLoadResFinished?: boolean;
    occurTime?: Date;
    loginTime?: Date;
    logoutTime?: Date;
}

export enum SessionType {
    Client_Mgr = 0,
    Client_Station = 1,
    Server = 2,
    System = 3,
    Target = 4,
    Unkonw = -1,
}

export class ShootingCountInfo implements IShootingCountInfo {
    occureTime?: Date;
    addr?: string | undefined;
    targetIdx?: number;
    shootingCount?: number;

    constructor(data?: IShootingCountInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.occureTime = _data["occureTime"] ? new Date(_data["occureTime"].toString()) : <any>undefined;
            this.addr = _data["addr"];
            this.targetIdx = _data["targetIdx"];
            this.shootingCount = _data["shootingCount"];
        }
    }

    static fromJS(data: any): ShootingCountInfo {
        data = typeof data === 'object' ? data : {};
        let result = new ShootingCountInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["occureTime"] = this.occureTime ? this.occureTime.toISOString() : <any>undefined;
        data["addr"] = this.addr;
        data["targetIdx"] = this.targetIdx;
        data["shootingCount"] = this.shootingCount;
        return data; 
    }
}

export interface IShootingCountInfo {
    occureTime?: Date;
    addr?: string | undefined;
    targetIdx?: number;
    shootingCount?: number;
}

export class TargetCtrlParam implements ITargetCtrlParam {
    targetId?: number[] | undefined;
    command?: number;
    param?: number;

    constructor(data?: ITargetCtrlParam) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["targetId"])) {
                this.targetId = [] as any;
                for (let item of _data["targetId"])
                    this.targetId!.push(item);
            }
            this.command = _data["command"];
            this.param = _data["param"];
        }
    }

    static fromJS(data: any): TargetCtrlParam {
        data = typeof data === 'object' ? data : {};
        let result = new TargetCtrlParam();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.targetId)) {
            data["targetId"] = [];
            for (let item of this.targetId)
                data["targetId"].push(item);
        }
        data["command"] = this.command;
        data["param"] = this.param;
        return data; 
    }
}

export interface ITargetCtrlParam {
    targetId?: number[] | undefined;
    command?: number;
    param?: number;
}

export class TargetIdxCtrlParam implements ITargetIdxCtrlParam {
    targetIdx?: number;
    command?: number;
    param?: number;

    constructor(data?: ITargetIdxCtrlParam) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.targetIdx = _data["targetIdx"];
            this.command = _data["command"];
            this.param = _data["param"];
        }
    }

    static fromJS(data: any): TargetIdxCtrlParam {
        data = typeof data === 'object' ? data : {};
        let result = new TargetIdxCtrlParam();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["targetIdx"] = this.targetIdx;
        data["command"] = this.command;
        data["param"] = this.param;
        return data; 
    }
}

export interface ITargetIdxCtrlParam {
    targetIdx?: number;
    command?: number;
    param?: number;
}

export class LoginParam implements ILoginParam {
    userName?: string | undefined;
    password?: string | undefined;

    constructor(data?: ILoginParam) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userName = _data["userName"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): LoginParam {
        data = typeof data === 'object' ? data : {};
        let result = new LoginParam();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["password"] = this.password;
        return data; 
    }
}

export interface ILoginParam {
    userName?: string | undefined;
    password?: string | undefined;
}

export class DevPersonParam implements IDevPersonParam {
    devs?: number[] | undefined;
    persons?: number[] | undefined;

    constructor(data?: IDevPersonParam) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["devs"])) {
                this.devs = [] as any;
                for (let item of _data["devs"])
                    this.devs!.push(item);
            }
            if (Array.isArray(_data["persons"])) {
                this.persons = [] as any;
                for (let item of _data["persons"])
                    this.persons!.push(item);
            }
        }
    }

    static fromJS(data: any): DevPersonParam {
        data = typeof data === 'object' ? data : {};
        let result = new DevPersonParam();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.devs)) {
            data["devs"] = [];
            for (let item of this.devs)
                data["devs"].push(item);
        }
        if (Array.isArray(this.persons)) {
            data["persons"] = [];
            for (let item of this.persons)
                data["persons"].push(item);
        }
        return data; 
    }
}

export interface IDevPersonParam {
    devs?: number[] | undefined;
    persons?: number[] | undefined;
}

export class DevAudioParam implements IDevAudioParam {
    devs?: number[] | undefined;
    audios?: string[] | undefined;

    constructor(data?: IDevAudioParam) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["devs"])) {
                this.devs = [] as any;
                for (let item of _data["devs"])
                    this.devs!.push(item);
            }
            if (Array.isArray(_data["audios"])) {
                this.audios = [] as any;
                for (let item of _data["audios"])
                    this.audios!.push(item);
            }
        }
    }

    static fromJS(data: any): DevAudioParam {
        data = typeof data === 'object' ? data : {};
        let result = new DevAudioParam();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.devs)) {
            data["devs"] = [];
            for (let item of this.devs)
                data["devs"].push(item);
        }
        if (Array.isArray(this.audios)) {
            data["audios"] = [];
            for (let item of this.audios)
                data["audios"].push(item);
        }
        return data; 
    }
}

export interface IDevAudioParam {
    devs?: number[] | undefined;
    audios?: string[] | undefined;
}

export class PtzCmdParam implements IPtzCmdParam {
    rscID?: number;
    ptzCmd?: number;
    ptzParam1?: number;
    ptzParam2?: number;
    ptzParam3?: number;
    ptzPreset?: string | undefined;

    constructor(data?: IPtzCmdParam) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.rscID = _data["rscID"];
            this.ptzCmd = _data["ptzCmd"];
            this.ptzParam1 = _data["ptzParam1"];
            this.ptzParam2 = _data["ptzParam2"];
            this.ptzParam3 = _data["ptzParam3"];
            this.ptzPreset = _data["ptzPreset"];
        }
    }

    static fromJS(data: any): PtzCmdParam {
        data = typeof data === 'object' ? data : {};
        let result = new PtzCmdParam();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["rscID"] = this.rscID;
        data["ptzCmd"] = this.ptzCmd;
        data["ptzParam1"] = this.ptzParam1;
        data["ptzParam2"] = this.ptzParam2;
        data["ptzParam3"] = this.ptzParam3;
        data["ptzPreset"] = this.ptzPreset;
        return data; 
    }
}

export interface IPtzCmdParam {
    rscID?: number;
    ptzCmd?: number;
    ptzParam1?: number;
    ptzParam2?: number;
    ptzParam3?: number;
    ptzPreset?: string | undefined;
}

export class PlayParam implements IPlayParam {
    resId?: number;
    tm?: MediaTransmitMode;
    st?: MediaStreamType;
    dstIP?: string | undefined;
    dstPort?: number;

    constructor(data?: IPlayParam) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.resId = _data["resId"];
            this.tm = _data["tm"];
            this.st = _data["st"];
            this.dstIP = _data["dstIP"];
            this.dstPort = _data["dstPort"];
        }
    }

    static fromJS(data: any): PlayParam {
        data = typeof data === 'object' ? data : {};
        let result = new PlayParam();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["resId"] = this.resId;
        data["tm"] = this.tm;
        data["st"] = this.st;
        data["dstIP"] = this.dstIP;
        data["dstPort"] = this.dstPort;
        return data; 
    }
}

export interface IPlayParam {
    resId?: number;
    tm?: MediaTransmitMode;
    st?: MediaStreamType;
    dstIP?: string | undefined;
    dstPort?: number;
}

export enum MediaTransmitMode {
    UDP = 0,
    TCP = 1,
}

export enum MediaStreamType {
    MainStream = 0,
    SubStream = 1,
}

export class PreSchemeHandledParam implements IPreSchemeHandledParam {
    previewId?: number;
    previewItemId?: number;
    result?: ErrorCode;
    desc?: string | undefined;
    timestamp?: string | undefined;

    constructor(data?: IPreSchemeHandledParam) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.previewId = _data["previewId"];
            this.previewItemId = _data["previewItemId"];
            this.result = _data["result"];
            this.desc = _data["desc"];
            this.timestamp = _data["timestamp"];
        }
    }

    static fromJS(data: any): PreSchemeHandledParam {
        data = typeof data === 'object' ? data : {};
        let result = new PreSchemeHandledParam();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["previewId"] = this.previewId;
        data["previewItemId"] = this.previewItemId;
        data["result"] = this.result;
        data["desc"] = this.desc;
        data["timestamp"] = this.timestamp;
        return data; 
    }
}

export interface IPreSchemeHandledParam {
    previewId?: number;
    previewItemId?: number;
    result?: ErrorCode;
    desc?: string | undefined;
    timestamp?: string | undefined;
}

export enum ErrorCode {
    Success = 0,
    Failed = -255,
    Nonexistent = -254,
    ArgInvalid = -253,
    ParamRepeat = -252,
    InvalidType = -251,
    NotSupport = -250,
    ParamIsNull = -249,
    PartSuccess = -248,
    SystemBusy = -247,
    FileOpConflict = -246,
    RestartService = -245,
    VersionNoAuth = -244,
    SessionInvalid = -243,
    SessionNotLogin = -242,
    UserHasLogined = -241,
    UserNonexistent = -240,
    UserLoginDuplicated = -239,
    UserInvalid = -238,
    UserPasswdInvalid = -237,
    UserNoPrivilege = -236,
    UserGrpInvalid = -235,
    UserGrpNonexistent = -234,
    UserNameDup = -233,
    CmdNotExist = -232,
    DevOpFailed = -231,
    DeviceOffline = -230,
    DevNonexistent = -229,
    DevIPAddrDup = -228,
    DevBusy = -227,
    NotInit = -226,
    DevTimeout = -225,
    StationSysIPRepeat = -224,
    StationNoBulletBox = -223,
    DoorCtrlHostNotConf = -222,
    GunCtrlHostNotConf = -221,
    DevCallNumDup = -220,
    DevConnectFailed = -219,
    DevSubServerOffline = -218,
    DevSubServerVerionError = -217,
    DBOperateFailed = -216,
    DBCreateFailed = -215,
    DBNullData = -214,
    DBNonexistent = -213,
    ConfigNotDel = -212,
    EventIsNull = -211,
    AlarmSrcNotEnable = -210,
    PlanIsNull = -209,
    PersonDisable = -208,
    PersonDuplicate = -207,
    OperationRepeat = -206,
}

export class MessageParam implements IMessageParam {
    itemId?: number;
    title?: string | undefined;
    message?: string | undefined;
    user?: number[] | undefined;

    constructor(data?: IMessageParam) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.itemId = _data["itemId"];
            this.title = _data["title"];
            this.message = _data["message"];
            if (Array.isArray(_data["user"])) {
                this.user = [] as any;
                for (let item of _data["user"])
                    this.user!.push(item);
            }
        }
    }

    static fromJS(data: any): MessageParam {
        data = typeof data === 'object' ? data : {};
        let result = new MessageParam();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["itemId"] = this.itemId;
        data["title"] = this.title;
        data["message"] = this.message;
        if (Array.isArray(this.user)) {
            data["user"] = [];
            for (let item of this.user)
                data["user"].push(item);
        }
        return data; 
    }
}

export interface IMessageParam {
    itemId?: number;
    title?: string | undefined;
    message?: string | undefined;
    user?: number[] | undefined;
}

export class UserInfo implements IUserInfo {
    id?: number;
    name!: string;
    isDelete?: boolean;
    isEnable?: boolean;
    userGroupId?: number;
    password?: string | undefined;
    relPersonName?: string | undefined;
    relPersonId?: number;
    encodeType?: PwEncodeType;
    encodeParam?: string | undefined;
    loginCount?: number;
    lastLoginTime?: Date;
    lastLoginAddr?: string | undefined;
    tag?: string | undefined;
    occurTime?: Date;
    modifyTime?: Date;
    userGroupInfo?: UserGroupInfo | undefined;

    constructor(data?: IUserInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.isDelete = _data["isDelete"];
            this.isEnable = _data["isEnable"];
            this.userGroupId = _data["userGroupId"];
            this.password = _data["password"];
            this.relPersonName = _data["relPersonName"];
            this.relPersonId = _data["relPersonId"];
            this.encodeType = _data["encodeType"];
            this.encodeParam = _data["encodeParam"];
            this.loginCount = _data["loginCount"];
            this.lastLoginTime = _data["lastLoginTime"] ? new Date(_data["lastLoginTime"].toString()) : <any>undefined;
            this.lastLoginAddr = _data["lastLoginAddr"];
            this.tag = _data["tag"];
            this.occurTime = _data["occurTime"] ? new Date(_data["occurTime"].toString()) : <any>undefined;
            this.modifyTime = _data["modifyTime"] ? new Date(_data["modifyTime"].toString()) : <any>undefined;
            this.userGroupInfo = _data["userGroupInfo"] ? UserGroupInfo.fromJS(_data["userGroupInfo"]) : <any>undefined;
        }
    }

    static fromJS(data: any): UserInfo {
        data = typeof data === 'object' ? data : {};
        let result = new UserInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["isDelete"] = this.isDelete;
        data["isEnable"] = this.isEnable;
        data["userGroupId"] = this.userGroupId;
        data["password"] = this.password;
        data["relPersonName"] = this.relPersonName;
        data["relPersonId"] = this.relPersonId;
        data["encodeType"] = this.encodeType;
        data["encodeParam"] = this.encodeParam;
        data["loginCount"] = this.loginCount;
        data["lastLoginTime"] = this.lastLoginTime ? this.lastLoginTime.toISOString() : <any>undefined;
        data["lastLoginAddr"] = this.lastLoginAddr;
        data["tag"] = this.tag;
        data["occurTime"] = this.occurTime ? this.occurTime.toISOString() : <any>undefined;
        data["modifyTime"] = this.modifyTime ? this.modifyTime.toISOString() : <any>undefined;
        data["userGroupInfo"] = this.userGroupInfo ? this.userGroupInfo.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IUserInfo {
    id?: number;
    name: string;
    isDelete?: boolean;
    isEnable?: boolean;
    userGroupId?: number;
    password?: string | undefined;
    relPersonName?: string | undefined;
    relPersonId?: number;
    encodeType?: PwEncodeType;
    encodeParam?: string | undefined;
    loginCount?: number;
    lastLoginTime?: Date;
    lastLoginAddr?: string | undefined;
    tag?: string | undefined;
    occurTime?: Date;
    modifyTime?: Date;
    userGroupInfo?: UserGroupInfo | undefined;
}

export enum PwEncodeType {
    MD5 = 0,
}

export class UserGroupInfo implements IUserGroupInfo {
    id?: number;
    name!: string;
    isDelete?: boolean;
    isEnable?: boolean;
    defType?: DefType;
    desc?: string | undefined;
    occurTime?: Date;
    modifyTime?: Date;
    purviewList?: UserGroupPurview[] | undefined;
    userInfos?: UserInfo[] | undefined;

    constructor(data?: IUserGroupInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.isDelete = _data["isDelete"];
            this.isEnable = _data["isEnable"];
            this.defType = _data["defType"];
            this.desc = _data["desc"];
            this.occurTime = _data["occurTime"] ? new Date(_data["occurTime"].toString()) : <any>undefined;
            this.modifyTime = _data["modifyTime"] ? new Date(_data["modifyTime"].toString()) : <any>undefined;
            if (Array.isArray(_data["purviewList"])) {
                this.purviewList = [] as any;
                for (let item of _data["purviewList"])
                    this.purviewList!.push(UserGroupPurview.fromJS(item));
            }
            if (Array.isArray(_data["userInfos"])) {
                this.userInfos = [] as any;
                for (let item of _data["userInfos"])
                    this.userInfos!.push(UserInfo.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UserGroupInfo {
        data = typeof data === 'object' ? data : {};
        let result = new UserGroupInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["isDelete"] = this.isDelete;
        data["isEnable"] = this.isEnable;
        data["defType"] = this.defType;
        data["desc"] = this.desc;
        data["occurTime"] = this.occurTime ? this.occurTime.toISOString() : <any>undefined;
        data["modifyTime"] = this.modifyTime ? this.modifyTime.toISOString() : <any>undefined;
        if (Array.isArray(this.purviewList)) {
            data["purviewList"] = [];
            for (let item of this.purviewList)
                data["purviewList"].push(item.toJSON());
        }
        if (Array.isArray(this.userInfos)) {
            data["userInfos"] = [];
            for (let item of this.userInfos)
                data["userInfos"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IUserGroupInfo {
    id?: number;
    name: string;
    isDelete?: boolean;
    isEnable?: boolean;
    defType?: DefType;
    desc?: string | undefined;
    occurTime?: Date;
    modifyTime?: Date;
    purviewList?: UserGroupPurview[] | undefined;
    userInfos?: UserInfo[] | undefined;
}

export class UserGroupPurview implements IUserGroupPurview {
    id?: number;
    userGroupID?: number;
    purviewKey?: string | undefined;
    purviewDesc?: number;
    occurTime?: Date;
    userGroupInfo?: UserGroupInfo | undefined;

    constructor(data?: IUserGroupPurview) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userGroupID = _data["userGroupID"];
            this.purviewKey = _data["purviewKey"];
            this.purviewDesc = _data["purviewDesc"];
            this.occurTime = _data["occurTime"] ? new Date(_data["occurTime"].toString()) : <any>undefined;
            this.userGroupInfo = _data["userGroupInfo"] ? UserGroupInfo.fromJS(_data["userGroupInfo"]) : <any>undefined;
        }
    }

    static fromJS(data: any): UserGroupPurview {
        data = typeof data === 'object' ? data : {};
        let result = new UserGroupPurview();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userGroupID"] = this.userGroupID;
        data["purviewKey"] = this.purviewKey;
        data["purviewDesc"] = this.purviewDesc;
        data["occurTime"] = this.occurTime ? this.occurTime.toISOString() : <any>undefined;
        data["userGroupInfo"] = this.userGroupInfo ? this.userGroupInfo.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IUserGroupPurview {
    id?: number;
    userGroupID?: number;
    purviewKey?: string | undefined;
    purviewDesc?: number;
    occurTime?: Date;
    userGroupInfo?: UserGroupInfo | undefined;
}

export class SystemKeyInfo implements ISystemKeyInfo {
    id?: number;
    cfgKey?: string | undefined;
    cfgValue?: string | undefined;
    cfgGroup?: string | undefined;
    desc?: string | undefined;
    occurTime?: Date;
    modifyTime?: Date;

    constructor(data?: ISystemKeyInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.cfgKey = _data["cfgKey"];
            this.cfgValue = _data["cfgValue"];
            this.cfgGroup = _data["cfgGroup"];
            this.desc = _data["desc"];
            this.occurTime = _data["occurTime"] ? new Date(_data["occurTime"].toString()) : <any>undefined;
            this.modifyTime = _data["modifyTime"] ? new Date(_data["modifyTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): SystemKeyInfo {
        data = typeof data === 'object' ? data : {};
        let result = new SystemKeyInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["cfgKey"] = this.cfgKey;
        data["cfgValue"] = this.cfgValue;
        data["cfgGroup"] = this.cfgGroup;
        data["desc"] = this.desc;
        data["occurTime"] = this.occurTime ? this.occurTime.toISOString() : <any>undefined;
        data["modifyTime"] = this.modifyTime ? this.modifyTime.toISOString() : <any>undefined;
        return data; 
    }
}

export interface ISystemKeyInfo {
    id?: number;
    cfgKey?: string | undefined;
    cfgValue?: string | undefined;
    cfgGroup?: string | undefined;
    desc?: string | undefined;
    occurTime?: Date;
    modifyTime?: Date;
}

export class SystemResourceInfo implements ISystemResourceInfo {
    id?: number;
    configValue?: string | undefined;
    param?: string | undefined;
    configGroup?: string | undefined;
    occurTime?: Date;
    modifyTime?: Date;

    constructor(data?: ISystemResourceInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.configValue = _data["configValue"];
            this.param = _data["param"];
            this.configGroup = _data["configGroup"];
            this.occurTime = _data["occurTime"] ? new Date(_data["occurTime"].toString()) : <any>undefined;
            this.modifyTime = _data["modifyTime"] ? new Date(_data["modifyTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): SystemResourceInfo {
        data = typeof data === 'object' ? data : {};
        let result = new SystemResourceInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["configValue"] = this.configValue;
        data["param"] = this.param;
        data["configGroup"] = this.configGroup;
        data["occurTime"] = this.occurTime ? this.occurTime.toISOString() : <any>undefined;
        data["modifyTime"] = this.modifyTime ? this.modifyTime.toISOString() : <any>undefined;
        return data; 
    }
}

export interface ISystemResourceInfo {
    id?: number;
    configValue?: string | undefined;
    param?: string | undefined;
    configGroup?: string | undefined;
    occurTime?: Date;
    modifyTime?: Date;
}

export class PersonInfo implements IPersonInfo {
    id?: number;
    name!: string;
    tag?: string | undefined;
    isDelete?: boolean;
    isEnable?: boolean;
    personType?: string | undefined;
    personPurview?: number;
    orgId?: number;
    department?: string | undefined;
    position?: string | undefined;
    personState?: WorkStateType;
    personNum?: string | undefined;
    sex?: SexType;
    nation?: string | undefined;
    political?: string | undefined;
    idCard?: string | undefined;
    address?: string | undefined;
    occurTime?: Date;
    modifyTime?: Date;
    description?: string | undefined;
    relConfigList?: PersonRelKeyInfo[] | undefined;
    relDataList?: PersonRelResourceInfo[] | undefined;

    constructor(data?: IPersonInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.tag = _data["tag"];
            this.isDelete = _data["isDelete"];
            this.isEnable = _data["isEnable"];
            this.personType = _data["personType"];
            this.personPurview = _data["personPurview"];
            this.orgId = _data["orgId"];
            this.department = _data["department"];
            this.position = _data["position"];
            this.personState = _data["personState"];
            this.personNum = _data["personNum"];
            this.sex = _data["sex"];
            this.nation = _data["nation"];
            this.political = _data["political"];
            this.idCard = _data["idCard"];
            this.address = _data["address"];
            this.occurTime = _data["occurTime"] ? new Date(_data["occurTime"].toString()) : <any>undefined;
            this.modifyTime = _data["modifyTime"] ? new Date(_data["modifyTime"].toString()) : <any>undefined;
            this.description = _data["description"];
            if (Array.isArray(_data["relConfigList"])) {
                this.relConfigList = [] as any;
                for (let item of _data["relConfigList"])
                    this.relConfigList!.push(PersonRelKeyInfo.fromJS(item));
            }
            if (Array.isArray(_data["relDataList"])) {
                this.relDataList = [] as any;
                for (let item of _data["relDataList"])
                    this.relDataList!.push(PersonRelResourceInfo.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PersonInfo {
        data = typeof data === 'object' ? data : {};
        let result = new PersonInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["tag"] = this.tag;
        data["isDelete"] = this.isDelete;
        data["isEnable"] = this.isEnable;
        data["personType"] = this.personType;
        data["personPurview"] = this.personPurview;
        data["orgId"] = this.orgId;
        data["department"] = this.department;
        data["position"] = this.position;
        data["personState"] = this.personState;
        data["personNum"] = this.personNum;
        data["sex"] = this.sex;
        data["nation"] = this.nation;
        data["political"] = this.political;
        data["idCard"] = this.idCard;
        data["address"] = this.address;
        data["occurTime"] = this.occurTime ? this.occurTime.toISOString() : <any>undefined;
        data["modifyTime"] = this.modifyTime ? this.modifyTime.toISOString() : <any>undefined;
        data["description"] = this.description;
        if (Array.isArray(this.relConfigList)) {
            data["relConfigList"] = [];
            for (let item of this.relConfigList)
                data["relConfigList"].push(item.toJSON());
        }
        if (Array.isArray(this.relDataList)) {
            data["relDataList"] = [];
            for (let item of this.relDataList)
                data["relDataList"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPersonInfo {
    id?: number;
    name: string;
    tag?: string | undefined;
    isDelete?: boolean;
    isEnable?: boolean;
    personType?: string | undefined;
    personPurview?: number;
    orgId?: number;
    department?: string | undefined;
    position?: string | undefined;
    personState?: WorkStateType;
    personNum?: string | undefined;
    sex?: SexType;
    nation?: string | undefined;
    political?: string | undefined;
    idCard?: string | undefined;
    address?: string | undefined;
    occurTime?: Date;
    modifyTime?: Date;
    description?: string | undefined;
    relConfigList?: PersonRelKeyInfo[] | undefined;
    relDataList?: PersonRelResourceInfo[] | undefined;
}

export enum WorkStateType {
    Unkonw = 0,
    OnTheJob = 1,
    BeOnLeave = 2,
    AssembleForTraining = 3,
    ExecutionTask = 4,
    Retired = 5,
}

export enum SexType {
    Male = 0,
    Female = 1,
}

export class PersonRelKeyInfo implements IPersonRelKeyInfo {
    id?: number;
    srcID?: number;
    configKey?: string | undefined;
    configValue?: string | undefined;
    occurTime?: Date;
    modifyTime?: Date;
    personInfo?: PersonInfo | undefined;

    constructor(data?: IPersonRelKeyInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.srcID = _data["srcID"];
            this.configKey = _data["configKey"];
            this.configValue = _data["configValue"];
            this.occurTime = _data["occurTime"] ? new Date(_data["occurTime"].toString()) : <any>undefined;
            this.modifyTime = _data["modifyTime"] ? new Date(_data["modifyTime"].toString()) : <any>undefined;
            this.personInfo = _data["personInfo"] ? PersonInfo.fromJS(_data["personInfo"]) : <any>undefined;
        }
    }

    static fromJS(data: any): PersonRelKeyInfo {
        data = typeof data === 'object' ? data : {};
        let result = new PersonRelKeyInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["srcID"] = this.srcID;
        data["configKey"] = this.configKey;
        data["configValue"] = this.configValue;
        data["occurTime"] = this.occurTime ? this.occurTime.toISOString() : <any>undefined;
        data["modifyTime"] = this.modifyTime ? this.modifyTime.toISOString() : <any>undefined;
        data["personInfo"] = this.personInfo ? this.personInfo.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IPersonRelKeyInfo {
    id?: number;
    srcID?: number;
    configKey?: string | undefined;
    configValue?: string | undefined;
    occurTime?: Date;
    modifyTime?: Date;
    personInfo?: PersonInfo | undefined;
}

export class PersonRelResourceInfo implements IPersonRelResourceInfo {
    id?: number;
    personId?: number;
    dataTag?: number;
    dataType?: PersonDataType;
    dataIndex?: number;
    vendor?: DevVendor;
    dataPath?: string | undefined;
    occurTime?: Date;
    modifyTime?: Date;
    personInfo?: PersonInfo | undefined;

    constructor(data?: IPersonRelResourceInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.personId = _data["personId"];
            this.dataTag = _data["dataTag"];
            this.dataType = _data["dataType"];
            this.dataIndex = _data["dataIndex"];
            this.vendor = _data["vendor"];
            this.dataPath = _data["dataPath"];
            this.occurTime = _data["occurTime"] ? new Date(_data["occurTime"].toString()) : <any>undefined;
            this.modifyTime = _data["modifyTime"] ? new Date(_data["modifyTime"].toString()) : <any>undefined;
            this.personInfo = _data["personInfo"] ? PersonInfo.fromJS(_data["personInfo"]) : <any>undefined;
        }
    }

    static fromJS(data: any): PersonRelResourceInfo {
        data = typeof data === 'object' ? data : {};
        let result = new PersonRelResourceInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["personId"] = this.personId;
        data["dataTag"] = this.dataTag;
        data["dataType"] = this.dataType;
        data["dataIndex"] = this.dataIndex;
        data["vendor"] = this.vendor;
        data["dataPath"] = this.dataPath;
        data["occurTime"] = this.occurTime ? this.occurTime.toISOString() : <any>undefined;
        data["modifyTime"] = this.modifyTime ? this.modifyTime.toISOString() : <any>undefined;
        data["personInfo"] = this.personInfo ? this.personInfo.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IPersonRelResourceInfo {
    id?: number;
    personId?: number;
    dataTag?: number;
    dataType?: PersonDataType;
    dataIndex?: number;
    vendor?: DevVendor;
    dataPath?: string | undefined;
    occurTime?: Date;
    modifyTime?: Date;
    personInfo?: PersonInfo | undefined;
}

export enum PersonDataType {
    FACE = 0,
    FINGER = 1,
    IRIS = 2,
    PASSWD = 3,
    CARD = 4,
    PHOTO = 5,
    FINGER_PHOTO = 6,
    UNKONW = -1,
}

export class PersonResData implements IPersonResData {
    id?: number;
    personId?: number;
    dataType?: PersonDataType;
    dataIndex?: number;
    vendor?: DevVendor;
    data?: string | undefined;

    constructor(data?: IPersonResData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.personId = _data["personId"];
            this.dataType = _data["dataType"];
            this.dataIndex = _data["dataIndex"];
            this.vendor = _data["vendor"];
            this.data = _data["data"];
        }
    }

    static fromJS(data: any): PersonResData {
        data = typeof data === 'object' ? data : {};
        let result = new PersonResData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["personId"] = this.personId;
        data["dataType"] = this.dataType;
        data["dataIndex"] = this.dataIndex;
        data["vendor"] = this.vendor;
        data["data"] = this.data;
        return data; 
    }
}

export interface IPersonResData {
    id?: number;
    personId?: number;
    dataType?: PersonDataType;
    dataIndex?: number;
    vendor?: DevVendor;
    data?: string | undefined;
}

export class VideoGroupInfo implements IVideoGroupInfo {
    id?: number;
    name!: string;
    groupType?: VideoGroupType;
    interval?: number;
    content?: string | undefined;
    tag?: string | undefined;
    occurTime?: Date;
    modifyTime?: Date;

    constructor(data?: IVideoGroupInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.groupType = _data["groupType"];
            this.interval = _data["interval"];
            this.content = _data["content"];
            this.tag = _data["tag"];
            this.occurTime = _data["occurTime"] ? new Date(_data["occurTime"].toString()) : <any>undefined;
            this.modifyTime = _data["modifyTime"] ? new Date(_data["modifyTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): VideoGroupInfo {
        data = typeof data === 'object' ? data : {};
        let result = new VideoGroupInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["groupType"] = this.groupType;
        data["interval"] = this.interval;
        data["content"] = this.content;
        data["tag"] = this.tag;
        data["occurTime"] = this.occurTime ? this.occurTime.toISOString() : <any>undefined;
        data["modifyTime"] = this.modifyTime ? this.modifyTime.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IVideoGroupInfo {
    id?: number;
    name: string;
    groupType?: VideoGroupType;
    interval?: number;
    content?: string | undefined;
    tag?: string | undefined;
    occurTime?: Date;
    modifyTime?: Date;
}

export enum VideoGroupType {
    All = 0,
    Client = 1,
    Station = 2,
}

export class VideoSceneInfo implements IVideoSceneInfo {
    id?: number;
    name!: string;
    isUsed?: boolean;
    defType?: DefType;
    windowCount?: number;
    content?: string | undefined;
    userID?: number;
    occurTime?: Date;
    modifyTime?: Date;

    constructor(data?: IVideoSceneInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.isUsed = _data["isUsed"];
            this.defType = _data["defType"];
            this.windowCount = _data["windowCount"];
            this.content = _data["content"];
            this.userID = _data["userID"];
            this.occurTime = _data["occurTime"] ? new Date(_data["occurTime"].toString()) : <any>undefined;
            this.modifyTime = _data["modifyTime"] ? new Date(_data["modifyTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): VideoSceneInfo {
        data = typeof data === 'object' ? data : {};
        let result = new VideoSceneInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["isUsed"] = this.isUsed;
        data["defType"] = this.defType;
        data["windowCount"] = this.windowCount;
        data["content"] = this.content;
        data["userID"] = this.userID;
        data["occurTime"] = this.occurTime ? this.occurTime.toISOString() : <any>undefined;
        data["modifyTime"] = this.modifyTime ? this.modifyTime.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IVideoSceneInfo {
    id?: number;
    name: string;
    isUsed?: boolean;
    defType?: DefType;
    windowCount?: number;
    content?: string | undefined;
    userID?: number;
    occurTime?: Date;
    modifyTime?: Date;
}

export class MapParam implements IMapParam {
    mapInfo?: MapInfo | undefined;
    mapData?: string | undefined;

    constructor(data?: IMapParam) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.mapInfo = _data["mapInfo"] ? MapInfo.fromJS(_data["mapInfo"]) : <any>undefined;
            this.mapData = _data["mapData"];
        }
    }

    static fromJS(data: any): MapParam {
        data = typeof data === 'object' ? data : {};
        let result = new MapParam();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["mapInfo"] = this.mapInfo ? this.mapInfo.toJSON() : <any>undefined;
        data["mapData"] = this.mapData;
        return data; 
    }
}

export interface IMapParam {
    mapInfo?: MapInfo | undefined;
    mapData?: string | undefined;
}

export class MapInfo implements IMapInfo {
    id?: number;
    name?: string | undefined;
    type?: ClientMapType;
    mapPicPath?: string | undefined;
    occurTime?: Date;
    modifyTime?: Date;
    desc?: string | undefined;
    mapRelAreaInfoList?: MapRelAreaInfo[] | undefined;
    mapRelMonitorInfoList?: MapRelMonitorInfo[] | undefined;

    constructor(data?: IMapInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.type = _data["type"];
            this.mapPicPath = _data["mapPicPath"];
            this.occurTime = _data["occurTime"] ? new Date(_data["occurTime"].toString()) : <any>undefined;
            this.modifyTime = _data["modifyTime"] ? new Date(_data["modifyTime"].toString()) : <any>undefined;
            this.desc = _data["desc"];
            if (Array.isArray(_data["mapRelAreaInfoList"])) {
                this.mapRelAreaInfoList = [] as any;
                for (let item of _data["mapRelAreaInfoList"])
                    this.mapRelAreaInfoList!.push(MapRelAreaInfo.fromJS(item));
            }
            if (Array.isArray(_data["mapRelMonitorInfoList"])) {
                this.mapRelMonitorInfoList = [] as any;
                for (let item of _data["mapRelMonitorInfoList"])
                    this.mapRelMonitorInfoList!.push(MapRelMonitorInfo.fromJS(item));
            }
        }
    }

    static fromJS(data: any): MapInfo {
        data = typeof data === 'object' ? data : {};
        let result = new MapInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["type"] = this.type;
        data["mapPicPath"] = this.mapPicPath;
        data["occurTime"] = this.occurTime ? this.occurTime.toISOString() : <any>undefined;
        data["modifyTime"] = this.modifyTime ? this.modifyTime.toISOString() : <any>undefined;
        data["desc"] = this.desc;
        if (Array.isArray(this.mapRelAreaInfoList)) {
            data["mapRelAreaInfoList"] = [];
            for (let item of this.mapRelAreaInfoList)
                data["mapRelAreaInfoList"].push(item.toJSON());
        }
        if (Array.isArray(this.mapRelMonitorInfoList)) {
            data["mapRelMonitorInfoList"] = [];
            for (let item of this.mapRelMonitorInfoList)
                data["mapRelMonitorInfoList"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IMapInfo {
    id?: number;
    name?: string | undefined;
    type?: ClientMapType;
    mapPicPath?: string | undefined;
    occurTime?: Date;
    modifyTime?: Date;
    desc?: string | undefined;
    mapRelAreaInfoList?: MapRelAreaInfo[] | undefined;
    mapRelMonitorInfoList?: MapRelMonitorInfo[] | undefined;
}

export enum ClientMapType {
    TwoD = 0,
}

export class MapRelAreaInfo implements IMapRelAreaInfo {
    id?: number;
    mapID?: number;
    name?: string | undefined;
    areaType?: AreaType;
    param?: string | undefined;
    occurTime?: Date;
    modifyTime?: Date;
    mapInfo?: MapInfo | undefined;

    constructor(data?: IMapRelAreaInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.mapID = _data["mapID"];
            this.name = _data["name"];
            this.areaType = _data["areaType"];
            this.param = _data["param"];
            this.occurTime = _data["occurTime"] ? new Date(_data["occurTime"].toString()) : <any>undefined;
            this.modifyTime = _data["modifyTime"] ? new Date(_data["modifyTime"].toString()) : <any>undefined;
            this.mapInfo = _data["mapInfo"] ? MapInfo.fromJS(_data["mapInfo"]) : <any>undefined;
        }
    }

    static fromJS(data: any): MapRelAreaInfo {
        data = typeof data === 'object' ? data : {};
        let result = new MapRelAreaInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["mapID"] = this.mapID;
        data["name"] = this.name;
        data["areaType"] = this.areaType;
        data["param"] = this.param;
        data["occurTime"] = this.occurTime ? this.occurTime.toISOString() : <any>undefined;
        data["modifyTime"] = this.modifyTime ? this.modifyTime.toISOString() : <any>undefined;
        data["mapInfo"] = this.mapInfo ? this.mapInfo.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IMapRelAreaInfo {
    id?: number;
    mapID?: number;
    name?: string | undefined;
    areaType?: AreaType;
    param?: string | undefined;
    occurTime?: Date;
    modifyTime?: Date;
    mapInfo?: MapInfo | undefined;
}

export enum AreaType {
    Building = 0,
    Label = 1,
}

export class MapRelMonitorInfo implements IMapRelMonitorInfo {
    id?: number;
    mapID?: number;
    monitorID?: number;
    posX?: number;
    posY?: number;
    posZ?: number;
    areaInfo?: string | undefined;
    featureInfo?: string | undefined;
    occurTime?: Date;
    modifyTime?: Date;
    mapInfo?: MapInfo | undefined;
    monitorInfo?: MonitorInfo | undefined;

    constructor(data?: IMapRelMonitorInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.mapID = _data["mapID"];
            this.monitorID = _data["monitorID"];
            this.posX = _data["posX"];
            this.posY = _data["posY"];
            this.posZ = _data["posZ"];
            this.areaInfo = _data["areaInfo"];
            this.featureInfo = _data["featureInfo"];
            this.occurTime = _data["occurTime"] ? new Date(_data["occurTime"].toString()) : <any>undefined;
            this.modifyTime = _data["modifyTime"] ? new Date(_data["modifyTime"].toString()) : <any>undefined;
            this.mapInfo = _data["mapInfo"] ? MapInfo.fromJS(_data["mapInfo"]) : <any>undefined;
            this.monitorInfo = _data["monitorInfo"] ? MonitorInfo.fromJS(_data["monitorInfo"]) : <any>undefined;
        }
    }

    static fromJS(data: any): MapRelMonitorInfo {
        data = typeof data === 'object' ? data : {};
        let result = new MapRelMonitorInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["mapID"] = this.mapID;
        data["monitorID"] = this.monitorID;
        data["posX"] = this.posX;
        data["posY"] = this.posY;
        data["posZ"] = this.posZ;
        data["areaInfo"] = this.areaInfo;
        data["featureInfo"] = this.featureInfo;
        data["occurTime"] = this.occurTime ? this.occurTime.toISOString() : <any>undefined;
        data["modifyTime"] = this.modifyTime ? this.modifyTime.toISOString() : <any>undefined;
        data["mapInfo"] = this.mapInfo ? this.mapInfo.toJSON() : <any>undefined;
        data["monitorInfo"] = this.monitorInfo ? this.monitorInfo.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IMapRelMonitorInfo {
    id?: number;
    mapID?: number;
    monitorID?: number;
    posX?: number;
    posY?: number;
    posZ?: number;
    areaInfo?: string | undefined;
    featureInfo?: string | undefined;
    occurTime?: Date;
    modifyTime?: Date;
    mapInfo?: MapInfo | undefined;
    monitorInfo?: MonitorInfo | undefined;
}

export class MonitorInfo implements IMonitorInfo {
    id?: number;
    name!: string;
    isDelete?: boolean;
    isEnable?: boolean;
    label?: string | undefined;
    desc?: string | undefined;
    occurTime?: Date;
    modifyTime?: Date;

    constructor(data?: IMonitorInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.isDelete = _data["isDelete"];
            this.isEnable = _data["isEnable"];
            this.label = _data["label"];
            this.desc = _data["desc"];
            this.occurTime = _data["occurTime"] ? new Date(_data["occurTime"].toString()) : <any>undefined;
            this.modifyTime = _data["modifyTime"] ? new Date(_data["modifyTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): MonitorInfo {
        data = typeof data === 'object' ? data : {};
        let result = new MonitorInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["isDelete"] = this.isDelete;
        data["isEnable"] = this.isEnable;
        data["label"] = this.label;
        data["desc"] = this.desc;
        data["occurTime"] = this.occurTime ? this.occurTime.toISOString() : <any>undefined;
        data["modifyTime"] = this.modifyTime ? this.modifyTime.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IMonitorInfo {
    id?: number;
    name: string;
    isDelete?: boolean;
    isEnable?: boolean;
    label?: string | undefined;
    desc?: string | undefined;
    occurTime?: Date;
    modifyTime?: Date;
}

export class MapRelKeyInfo implements IMapRelKeyInfo {
    id?: number;
    srcID?: number;
    configKey?: string | undefined;
    configValue?: string | undefined;
    occurTime?: Date;
    modifyTime?: Date;
    mapInfo?: MapInfo | undefined;

    constructor(data?: IMapRelKeyInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.srcID = _data["srcID"];
            this.configKey = _data["configKey"];
            this.configValue = _data["configValue"];
            this.occurTime = _data["occurTime"] ? new Date(_data["occurTime"].toString()) : <any>undefined;
            this.modifyTime = _data["modifyTime"] ? new Date(_data["modifyTime"].toString()) : <any>undefined;
            this.mapInfo = _data["mapInfo"] ? MapInfo.fromJS(_data["mapInfo"]) : <any>undefined;
        }
    }

    static fromJS(data: any): MapRelKeyInfo {
        data = typeof data === 'object' ? data : {};
        let result = new MapRelKeyInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["srcID"] = this.srcID;
        data["configKey"] = this.configKey;
        data["configValue"] = this.configValue;
        data["occurTime"] = this.occurTime ? this.occurTime.toISOString() : <any>undefined;
        data["modifyTime"] = this.modifyTime ? this.modifyTime.toISOString() : <any>undefined;
        data["mapInfo"] = this.mapInfo ? this.mapInfo.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IMapRelKeyInfo {
    id?: number;
    srcID?: number;
    configKey?: string | undefined;
    configValue?: string | undefined;
    occurTime?: Date;
    modifyTime?: Date;
    mapInfo?: MapInfo | undefined;
}

export class MonitorRelResourceInfo implements IMonitorRelResourceInfo {
    id?: number;
    monitorID?: number;
    resourceID?: number;
    resType?: ResType;
    occurTime?: Date;
    monitorInfo?: MonitorInfo | undefined;
    resourceInfo?: ResourceInfo | undefined;

    constructor(data?: IMonitorRelResourceInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.monitorID = _data["monitorID"];
            this.resourceID = _data["resourceID"];
            this.resType = _data["resType"];
            this.occurTime = _data["occurTime"] ? new Date(_data["occurTime"].toString()) : <any>undefined;
            this.monitorInfo = _data["monitorInfo"] ? MonitorInfo.fromJS(_data["monitorInfo"]) : <any>undefined;
            this.resourceInfo = _data["resourceInfo"] ? ResourceInfo.fromJS(_data["resourceInfo"]) : <any>undefined;
        }
    }

    static fromJS(data: any): MonitorRelResourceInfo {
        data = typeof data === 'object' ? data : {};
        let result = new MonitorRelResourceInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["monitorID"] = this.monitorID;
        data["resourceID"] = this.resourceID;
        data["resType"] = this.resType;
        data["occurTime"] = this.occurTime ? this.occurTime.toISOString() : <any>undefined;
        data["monitorInfo"] = this.monitorInfo ? this.monitorInfo.toJSON() : <any>undefined;
        data["resourceInfo"] = this.resourceInfo ? this.resourceInfo.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IMonitorRelResourceInfo {
    id?: number;
    monitorID?: number;
    resourceID?: number;
    resType?: ResType;
    occurTime?: Date;
    monitorInfo?: MonitorInfo | undefined;
    resourceInfo?: ResourceInfo | undefined;
}

export class MapRelResourceInfo implements IMapRelResourceInfo {
    id?: number;
    mapID?: number;
    resType?: ResType;
    resID?: number;
    param?: string | undefined;
    occurTime?: Date;
    modifyTime?: Date;
    mapInfo?: MapInfo | undefined;
    resourceInfo?: ResourceInfo | undefined;

    constructor(data?: IMapRelResourceInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.mapID = _data["mapID"];
            this.resType = _data["resType"];
            this.resID = _data["resID"];
            this.param = _data["param"];
            this.occurTime = _data["occurTime"] ? new Date(_data["occurTime"].toString()) : <any>undefined;
            this.modifyTime = _data["modifyTime"] ? new Date(_data["modifyTime"].toString()) : <any>undefined;
            this.mapInfo = _data["mapInfo"] ? MapInfo.fromJS(_data["mapInfo"]) : <any>undefined;
            this.resourceInfo = _data["resourceInfo"] ? ResourceInfo.fromJS(_data["resourceInfo"]) : <any>undefined;
        }
    }

    static fromJS(data: any): MapRelResourceInfo {
        data = typeof data === 'object' ? data : {};
        let result = new MapRelResourceInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["mapID"] = this.mapID;
        data["resType"] = this.resType;
        data["resID"] = this.resID;
        data["param"] = this.param;
        data["occurTime"] = this.occurTime ? this.occurTime.toISOString() : <any>undefined;
        data["modifyTime"] = this.modifyTime ? this.modifyTime.toISOString() : <any>undefined;
        data["mapInfo"] = this.mapInfo ? this.mapInfo.toJSON() : <any>undefined;
        data["resourceInfo"] = this.resourceInfo ? this.resourceInfo.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IMapRelResourceInfo {
    id?: number;
    mapID?: number;
    resType?: ResType;
    resID?: number;
    param?: string | undefined;
    occurTime?: Date;
    modifyTime?: Date;
    mapInfo?: MapInfo | undefined;
    resourceInfo?: ResourceInfo | undefined;
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}